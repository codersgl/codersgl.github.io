<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="/2024/05/17/Markdown%20Reference/"/>
      <url>/2024/05/17/Markdown%20Reference/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown-For-Typora"><a href="#Markdown-For-Typora" class="headerlink" title="Markdown For Typora"></a>Markdown For Typora</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Markdown由 <a href="http://daringfireball.net/">Daring Fireball</a>创建；原始指南在 <a href="http://daringfireball.net/projects/markdown/syntax">这里</a>。然而，其语法在不同的解析器或编辑器之间有所不同。Typora使用的是<a href="https://help.github.com/articles/github-flavored-markdown/">GitHub Flavored Markdown</a>.</p><h2 id="块级元素详解"><a href="#块级元素详解" class="headerlink" title="块级元素详解"></a>块级元素详解</h2><h3 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h3><p>段落是一行或多行连续的文本。在Markdown源代码中，段落由两个或更多的空白行分隔。在Typora中，只需要一个空白行（按一次回车键）即可创建一个新段落。</p><p>按<code>Shift + 回车键</code>可以创建一个单独的换行。大多数其他Markdown解析器会忽略单独的换行，所以为了让其他Markdown解析器识别您的换行，您可以在行尾留两个空格，或者插入<code>&lt;br/&gt;</code>。</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>标题使用1-6个井号(<code>#</code>)字符在行的开始，对应标题级别1-6。<br>例如：<br>在Typora中，输入井号<code>#</code>后跟标题内容，然后按回车键即可创建标题。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># This is an H1</span></span><br><span class="line"></span><br><span class="line"><span class="section">## This is an H2</span></span><br><span class="line"></span><br><span class="line"><span class="section">###### This is an H6</span></span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>Markdown使用电子邮件风格的<code>&gt;</code>字符进行块引用。它们显示为：<br>在Typora中，输入<code>&gt;</code>后跟您的引用内容将生成一个引用块。Typora将为您插入适当的<code>&gt;</code>或换行。通过添加额外级别的<code>&gt;</code>来嵌套块引用（一个块引用内另一个块引用）。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; This is a blockquote with two paragraphs. This is first paragraph.</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; This is second pragraph. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; This is another blockquote with one paragraph. There is three empty line to seperate two blockquote.</span></span><br></pre></td></tr></table></figure><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>输入<code>* list item 1</code>将创建一个无序列表 - <code>*</code>符号可以替换为<code>+</code>或<code>-</code>。<br>输入<code>1. list item 1</code>将创建一个有序列表 - 它们的Markdown源代码如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## un-ordered list</span></span><br><span class="line"><span class="bullet">*</span>   Red</span><br><span class="line"><span class="bullet">*</span>   Green</span><br><span class="line"><span class="bullet">*</span>   Blue</span><br><span class="line"></span><br><span class="line"><span class="section">## ordered list</span></span><br><span class="line"><span class="bullet">1.</span>  Red</span><br><span class="line"><span class="bullet">2.</span> Green</span><br><span class="line"><span class="bullet">3.</span>Blue</span><br></pre></td></tr></table></figure><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><p>任务列表是带有标记为<code>[ ]</code>或<code>[x]</code>（未完成或已完成）的项目列表。例如：<br>您可以通过点击项目前的复选框来改变完成&#x2F;未完成的状态。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [ ] a task list item</span><br><span class="line"><span class="bullet">-</span> [ ] list syntax required</span><br><span class="line"><span class="bullet">-</span> [ ] normal <span class="strong">**formatting**</span>, @mentions, #1234 refs</span><br><span class="line"><span class="bullet">-</span> [ ] incomplete</span><br><span class="line"><span class="bullet">-</span> [x] completed</span><br></pre></td></tr></table></figure><h3 id="代码块（围栏式）"><a href="#代码块（围栏式）" class="headerlink" title="代码块（围栏式）"></a>代码块（围栏式）</h3><p>Typora仅支持GitHub Flavored Markdown中的围栏。原始Markdown中的代码块不支持。<br>使用围栏很简单：输入 “&#96;&#96;&#96;”  然后按回车。在后面添加可选的语言标识符，我们将通过语法高亮来运行它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Here&#x27;s an example:</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">function test() &#123;</span><br><span class="line">  console.log(&quot;notice the blank line before this function?&quot;);</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">syntax highlighting:</span><br><span class="line">```ruby</span><br><span class="line">require &#x27;redcarpet&#x27;</span><br><span class="line">markdown = Redcarpet.new(&quot;Hello World!&quot;)</span><br><span class="line">puts markdown.to_html</span><br><span class="line">```</span><br></pre></td></tr></table></figure><h3 id="数学公式块"><a href="#数学公式块" class="headerlink" title="数学公式块"></a>数学公式块</h3><p>您可以使用MathJax渲染LaTeX数学表达式。<br>要添加一个数学表达式，输入<code>$$</code>然后按’回车’键。这将触发一个输入字段，接受Tex&#x2F;LaTex源代码。例如：<br>在Markdown源文件中，数学公式块是由一对<code>$$</code>标记包装的LaTeX表达式：</p><p>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 &#x3D;  \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>$$</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>输入<code>| First Header | Second Header |</code>然后按回车键。这将创建一个两列的表格。<br>创建表格后，将焦点放在该表格上将打开一个表格工具栏，您可以在其中调整大小、对齐或删除表格。您还可以使用上下文菜单复制和添加&#x2F;删除单个列&#x2F;行。<br>表格的完整语法如下，但不需要详细了解完整的语法，因为Typora会自动生成表格的Markdown源代码。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| First Header  | Second Header |</span><br><span class="line">| ------------- | ------------- |</span><br><span class="line">| Content Cell  | Content Cell  |</span><br><span class="line">| Content Cell  | Content Cell  |</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| Left-Aligned  | Center Aligned  | Right Aligned |</span><br><span class="line">| :------------ |:---------------:| -----:|</span><br><span class="line">| col 3 is      | some wordy text | $1600 |</span><br><span class="line">| col 2 is      | centered        |   $12 |</span><br><span class="line">| zebra stripes | are neat        |    $1 |</span><br></pre></td></tr></table></figure><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将产生：</span><br><span class="line">您可以像这样创建脚注[^footnote]。</span><br><span class="line">将鼠标悬停在‘脚注’上标以查看脚注的内容。</span><br></pre></td></tr></table></figure><p>[^footnote]: Here is the <em>text</em> of the <strong>footnote</strong>.</p><h3 id="水平规则"><a href="#水平规则" class="headerlink" title="水平规则"></a>水平规则</h3><p>在空行上输入<code>***</code>或<code>---</code>然后按回车键将绘制一条水平线。</p><hr><h3 id="YAML前言"><a href="#YAML前言" class="headerlink" title="YAML前言"></a>YAML前言</h3><p>Typora现在支持YAML前言。在文章顶部输入<code>---</code>然后按回车键以引入一个元数据块。或者，您可以从Typora的顶部菜单插入一个元数据块。</p><h3 id="目录（TOC）"><a href="#目录（TOC）" class="headerlink" title="目录（TOC）"></a>目录（TOC）</h3><p>输入<code>[toc]</code>然后按回车键。这将创建一个“目录”部分。TOC从文档中提取所有标题，随着您向文档添加内容，其内容将自动更新。</p><h2 id="内联元素详解"><a href="#内联元素详解" class="headerlink" title="内联元素详解"></a>内联元素详解</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>Markdown支持两种风格的链接：内联和引用。</p><p>在这两种样式中，链接文本都由[方括号]分隔。</p><p>要创建内联链接，请在链接文本的右方括号后立即使用一组常规括号。在括号内，将URL放在您希望链接指向的位置，以及链接的可选标题，用引号括起来。例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这是[一个例子]（http://example.com/&quot;标题&quot;）内联链接。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[此链接]（http://example.net/）没有标题属性。</span><br></pre></td></tr></table></figure><p>将产生：</p><p>这是[一个例子]（<a href="http://example.com/%22%E6%A0%87%E9%A2%98%22%EF%BC%89%E5%86%85%E8%81%94%E9%93%BE%E6%8E%A5%E3%80%82%EF%BC%88%60">http://example.com/&quot;标题&quot;）内联链接。（`</a><p>这是&lt;a href&#x3D;”<a href="http://example.com/%22title=%22Title%22%3E%60%EF%BC%89">http://example.com/&quot;title=&quot;Title&quot;&gt;`）</a></p><p>[此链接]（<a href="http://example.net/%EF%BC%89%E6%B2%A1%E6%9C%89%E6%A0%87%E9%A2%98%E5%B1%9E%E6%80%A7%E3%80%82%EF%BC%88%60">http://example.net/）没有标题属性。（`</a><p><a href="http://example.net/">此链接</a>没有&#96;）</p><h4 id="内部链接"><a href="#内部链接" class="headerlink" title="内部链接"></a>内部链接</h4><p><strong>您可以将href设置为标题</strong>，这将创建一个书签，允许您在单击后跳转到该部分。例如：</p><p>命令（在Windows上：Ctrl）+单击[此链接]（#block元素）将跳转到标题“块元素”。要查看如何编写它，请移动光标或单击该链接并按下“😍”键以将元素扩展到降价源。</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p>引用样式链接使用第二组方括号，在其中放置您选择的标签以标识链接：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这是[<span class="string">一个示例</span>][<span class="symbol">id</span>]引用样式链接。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">然后，在文档中的任何位置，您将链接标签单独定义在一行上，如下所示：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[id]：http://example.com/&quot;可选标题在这里&quot;</span><br></pre></td></tr></table></figure><p>在Typora中，它们将被渲染为：</p><p>这是[一个示例][id]引用样式链接。</p><p>[id]：<a href="http://example.com/">http://example.com/</a> “可选标题在这里”</p><p>隐式链接名称快捷方式允许您省略链接名称，在这种情况下，链接文本本身被用作名称。只需使用一组空方括号——例如，要将单词“谷歌”链接到google.com网站，您可以简单地写：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">谷歌</span>][<span class="symbol"></span>]</span><br><span class="line">然后定义链接：</span><br><span class="line"></span><br><span class="line">[谷歌]：http://google.com/</span><br></pre></td></tr></table></figure><p>在Typora中，单击链接将展开它以进行编辑，命令+单击将在您的Web浏览器中打开超链接。</p><h3 id="URLs"><a href="#URLs" class="headerlink" title="URLs"></a>URLs</h3><p>Typora允许您将URL作为链接插入，由“&lt;”括号“&gt;”包装。</p><p><code>&lt;i@typora.io&gt;</code>变为<a href="mailto:&#105;&#64;&#x74;&#x79;&#112;&#111;&#x72;&#x61;&#x2e;&#x69;&#111;">&#105;&#64;&#x74;&#x79;&#112;&#111;&#x72;&#x61;&#x2e;&#x69;&#111;</a>。</p><p>Typora还将自动链接标准URL。例如：<a href="http://www.google.com./">www.google.com。</a></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>图片的语法与链接类似，但它们需要在链接开始前增加一个额外的<code>!</code>字符。插入图片的语法如下所示：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">Alt text</span>](<span class="link">/path/to/img.jpg</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">Alt text</span>](<span class="link">/path/to/img.jpg &quot;Optional title&quot;</span>)</span><br></pre></td></tr></table></figure><p>您可以通过拖放从图像文件或您的网络浏览器插入图片。您可以通过点击图片来修改Markdown源代码。如果通过拖放添加的图像与您当前编辑的文档在同一目录或子目录中，则将使用相对路径。<br>如果您使用Markdown构建网站，您可以在YAML前言中使用属性typora-root-url为本地计算机上的图像预览指定URL前缀。例如，在YAML前言中输入<code>typora-root-url：/User/Abner/Website/typora.io/</code>，然后<img src="/blog/img/test.png" alt="alt">将被视为<code>![alt](file:///User/Abner/Website/typora.io/blog/img/test.png)。</code></p><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>Markdown将星号(<em>)和下划线(_)视为强调的指示符。用一个</em>或_包围的文本将被包装在HTML <code>&lt;em&gt;</code>标签中。例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*single asterisks*</span></span><br><span class="line"></span><br><span class="line"><span class="emphasis">_single underscores_</span></span><br></pre></td></tr></table></figure><p>output:</p><p><em>single asterisks</em></p><p><em>single underscores</em></p><h3 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h3><p>双星号或双下划线将使其包围的内容被包装在HTML <code>&lt;strong&gt;</code>标签中，例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**double asterisks**</span></span><br><span class="line"></span><br><span class="line"><span class="strong">__double underscores__</span></span><br></pre></td></tr></table></figure><p>output:</p><p><strong>double asterisks</strong></p><p><strong>double underscores</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>要表示内联的代码段，请用反引号(&#96;)将其包装起来。与预格式化的代码块不同，代码段表示在正常段落中的代码。例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Use the <span class="code">`printf()`</span> function.</span><br></pre></td></tr></table></figure><p>will produce:</p><p>Use the <code>printf()</code> function.</p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>GFM添加了创建删除线文本的语法，这在标准Markdown中是缺失的。<br><code>~~Mistaken text.~~</code> 变成 <del>Mistaken text.</del>。</p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>下划线由原始HTML支持。<br><code>&lt;u&gt;Underline&lt;/u&gt;</code> 变成<u>Underline</u>。</p><h3 id="表情符号-😄"><a href="#表情符号-😄" class="headerlink" title="表情符号 😄"></a>表情符号 😄</h3><p>使用语法<code>:smile:</code> 输入表情符号。<br>用户可以通过按ESC键触发表情符号的自动完成建议，或者在偏好面板上启用后自动触发。此外，直接输入UTF-8表情符号字符也由菜单栏中的编辑<code>Edit</code> -&gt; <code>Emoji &amp; Symbols</code>（macOS）支持。</p><h3 id="内联数学公式"><a href="#内联数学公式" class="headerlink" title="内联数学公式"></a>内联数学公式</h3><p>要使用此功能，请先在偏好面板 -&gt; Markdown标签中启用它。然后，使用<code>$</code>来包装TeX命令。例如：<code>$\lim_&#123;x \to \infty&#125; \exp(-x) = 0$</code>将被渲染为LaTeX命令。<br>要触发内联数学公式的内联预览：输入“$”，然后按ESC键，然后输入TeX命令。</p><p>你可以在 <a href="https://support.typora.io/Math/">这里</a>找到跟多关于内联数学公式的细节。</p><h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><p>要使用此功能，请先在<code>偏好面板</code> -&gt; <code>Markdown</code>标签中启用它。然后，使用<code>~</code>来包装下标内容。例如：<code>H~2~O</code>, <code>X~long\ text~</code>&#x2F;</p><h3 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h3><p>要使用此功能，请先在<code>偏好面板</code> -&gt;<code> Markdown</code>标签中启用它。然后，使用<code>^</code>来包装上标内容。例如：<code>X^2^</code>。</p><h3 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h3><p>要使用此功能，请先在<code>偏好面板</code> -&gt; <code>Markdown</code>标签中启用它。然后，使用<code>==</code>来包装高亮内容。例如：<code>==highlight==</code>。</p><p>由于文档内容较长，我将继续翻译剩余的部分。</p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>您可以使用HTML来为纯Markdown不支持的内容设置样式。例如，使用<code>&lt;span style=&quot;color:red&quot;&gt;this text is red&lt;/span&gt;</code>来添加红色文字。</p><h3 id="嵌入内容"><a href="#嵌入内容" class="headerlink" title="嵌入内容"></a>嵌入内容</h3><p>一些网站提供的基于iframe的嵌入代码也可以粘贴到Typora中。例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">height</span>=<span class="string">&#x27;265&#x27;</span> <span class="attr">scrolling</span>=<span class="string">&#x27;no&#x27;</span> <span class="attr">title</span>=<span class="string">&#x27;Fancy Animated SVG Menu&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;http://codepen.io/jeangontijo/embed/OxVywj/?height=265&amp;theme-id=0&amp;default-tab=css,result&amp;embed-version=2&#x27;</span> <span class="attr">frameborder</span>=<span class="string">&#x27;no&#x27;</span> <span class="attr">allowtransparency</span>=<span class="string">&#x27;true&#x27;</span> <span class="attr">allowfullscreen</span>=<span class="string">&#x27;true&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;width: 100%;&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p>您可以使用HTML的<code>&lt;video&gt;</code>标签来嵌入视频。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;xxx.mp4&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="其他HTML支持"><a href="#其他HTML支持" class="headerlink" title="其他HTML支持"></a>其他HTML支持</h3><p>您可以在 <a href="https://support.typora.io/HTML/">这里</a>找到更多细节。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>向量组的秩和线性组合</title>
      <link href="/2024/05/17/%E5%90%91%E9%87%8F%E7%BB%84%E7%9A%84%E7%A7%A9%E5%92%8C%E7%BA%BF%E6%80%A7%E7%BB%84%E5%90%88/"/>
      <url>/2024/05/17/%E5%90%91%E9%87%8F%E7%BB%84%E7%9A%84%E7%A7%A9%E5%92%8C%E7%BA%BF%E6%80%A7%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="向量组的秩和线性组合"><a href="#向量组的秩和线性组合" class="headerlink" title="向量组的秩和线性组合"></a>向量组的秩和线性组合</h1><p><img src="https://sfile.chatglm.cn/chatglm4/377f831c-4a20-4cb4-a085-8e5a7eb294f4.png?image_process=format,webp"></p><h1 id="啥是向量组？"><a href="#啥是向量组？" class="headerlink" title="啥是向量组？"></a>啥是向量组？</h1><p><img src="https://sfile.chatglm.cn/chatglm4/74e63b20-771c-4028-b99b-455335020a2f.png?image_process=format,webp"></p><h1 id="秩：独立向量的个数"><a href="#秩：独立向量的个数" class="headerlink" title="秩：独立向量的个数"></a>秩：独立向量的个数</h1><p><img src="https://sfile.chatglm.cn/chatglm4/018296ce-a162-42fb-8103-3d16e9f3121b.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/0a520cb6-8c1d-49ca-97b3-51febf6aa53d.png?image_process=format,webp"></p><h1 id="向量的运算"><a href="#向量的运算" class="headerlink" title="向量的运算"></a>向量的运算</h1><p><img src="https://sfile.chatglm.cn/chatglm4/245d93ac-7d94-4830-9e50-0ce1a45b4d4c.png?image_process=format,webp"></p><h1 id="向量组的线性表示"><a href="#向量组的线性表示" class="headerlink" title="向量组的线性表示"></a>向量组的线性表示</h1><p><img src="https://sfile.chatglm.cn/chatglm4/545dd742-20d1-4c46-ab96-448f3ad17280.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/df9b5399-dcf9-400f-8f4d-d7d878e1a73a.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/3ab63242-4edf-4787-97fe-7bb6650bb5e0.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/c2d9f4e3-41a8-425e-b86b-6a3d6d99dc54.png?image_process=format,webp"></p><h2 id="eg1"><a href="#eg1" class="headerlink" title="eg1"></a>eg1</h2><p><img src="https://sfile.chatglm.cn/chatglm4/050faf4f-5cf3-464f-92b6-c15ad2c435a1.png?image_process=format,webp"></p><h2 id="eg2"><a href="#eg2" class="headerlink" title="eg2"></a>eg2</h2><p><img src="https://sfile.chatglm.cn/chatglm4/4b712caa-a3e4-4473-9c7b-50228440645d.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/2bd3c288-a29e-4fe7-a07b-df3fd15bd687.png?image_process=format,webp"></p><hr><p><img src="https://sfile.chatglm.cn/chatglm4/1640c54d-90c4-4ef0-ba93-072e0a2e9818.png?image_process=format,webp"></p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵 </tag>
            
            <tag> 向量组 </tag>
            
            <tag> 秩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼树代码实现</title>
      <link href="/2024/05/16/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/05/16/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="哈夫曼树代码实现"><a href="#哈夫曼树代码实现" class="headerlink" title="哈夫曼树代码实现"></a>哈夫曼树代码实现</h1><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>优先队列（Priority Queue）是一种特殊的队列，它允许我们对队列中的元素进行优先级排序。在普通的队列中，元素按照先进先出（FIFO）的原则进行操作，即先添加到队列中的元素会先被移除。然而，在优先队列中，元素的出队顺序取决于它们的优先级，而不是它们被添加的顺序。</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ol><li><strong>元素排序</strong>：优先队列中的元素会根据它们的优先级进行排序。</li><li><strong>出队规则</strong>：队列中优先级最高的元素会最先被移除。</li><li><strong>动态性</strong>：元素的优先级可以是动态变化的，也可以是静态不变的。</li></ol><h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><ul><li><strong>任务调度</strong>：在操作系统中，优先队列用于调度任务，优先级高的任务会先被执行。</li><li><strong>事件驱动模拟</strong>：在事件驱动的系统中，优先队列可以用于安排事件，确保优先级高的事件先被处理。</li><li><strong>数据压缩</strong>：例如霍夫曼编码树的构建过程中，优先队列被用来选择频率最低的符号进行合并。</li></ul><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><p>优先队列可以用不同的数据结构实现，常见的有：</p><ul><li><strong>二叉堆</strong>：通常使用二叉堆来实现优先队列，因为二叉堆可以高效地支持优先队列的操作，如插入元素（O(log n)）和删除最小（或最大）元素（O(log n)）。</li><li><strong>斐波那契堆</strong>：一种更加高效的数据结构，特别适用于优先队列的某些应用，如图算法中的最小生成树和最短路径算法。</li><li><strong>数组</strong>：在某些情况下，也可以使用数组来模拟优先队列，但效率较低。</li></ul><h3 id="编程语言中的实现："><a href="#编程语言中的实现：" class="headerlink" title="编程语言中的实现："></a>编程语言中的实现：</h3><p>在许多编程语言中，如Python、Java、C++等，都有现成的库或类来实现优先队列。例如：</p><ul><li><strong>Python</strong>：<code>heapq</code>模块提供了堆队列算法的实现。</li><li><strong>Java</strong>：<code>java.util.PriorityQueue</code>类是一个无界优先队列的实现。</li><li>**C++**：<code>std::priority_queue</code>是C++标准库中的优先队列实现。</li></ul><p>优先队列是一种非常有用的数据结构，适用于需要根据元素优先级进行排序和处理的场景。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义哈夫曼书的节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, char, freq</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :param char:字符</span></span><br><span class="line"><span class="string">        :param freq:字符的频率</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.char = char  <span class="comment"># 节点代表的字符</span></span><br><span class="line">        self.freq = freq  <span class="comment"># 字符的频率</span></span><br><span class="line">        self.left = <span class="literal">None</span>  <span class="comment"># 左子节点</span></span><br><span class="line">        self.right = <span class="literal">None</span>  <span class="comment"># 右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义比较操作，以便在优先队列中使用</span></span><br><span class="line">    <span class="comment"># 使得频率最小的节点优先被取出</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.freq &lt; other.freq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建哈夫曼树函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_huffman_tree</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="comment"># 计算每个字符的频率</span></span><br><span class="line">    freq_map = collections.Counter(text)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建优先队列，队列中的元素为Node对象</span></span><br><span class="line">    priority_queue = [Node(char, freq) <span class="keyword">for</span> char, freq <span class="keyword">in</span> freq_map.items()]</span><br><span class="line">    heapq.heapify(priority_queue)  <span class="comment"># 将列表转化为堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建哈夫曼树</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(priority_queue) &gt; <span class="number">1</span>:</span><br><span class="line">        left = heapq.heappop(priority_queue)  <span class="comment"># 弹出频率最小的节点作为左子节点</span></span><br><span class="line">        right = heapq.heappop(priority_queue)  <span class="comment"># 弹出频率次小的节点作为右子节点</span></span><br><span class="line"></span><br><span class="line">        merged = Node(<span class="literal">None</span>, left.freq + right.freq)  <span class="comment"># 创建新节点，频率为左右子节点的频率和</span></span><br><span class="line">        merged.left = left</span><br><span class="line">        merged.right = right</span><br><span class="line"></span><br><span class="line">        heapq.heappush(priority_queue, merged)  <span class="comment"># 将新节点加入优先队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> priority_queue[<span class="number">0</span>]  <span class="comment"># 返回构建好的哈夫曼树的根节点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建哈夫曼编码的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_huffman_codes</span>(<span class="params">root, current_code=<span class="string">&quot;&quot;</span>, codes=&#123;&#125;</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param root:哈夫曼树的根节点</span></span><br><span class="line"><span class="string">    :param current_code:当前的哈夫曼编码的路径</span></span><br><span class="line"><span class="string">    :param codes:存放每个字符的编码路径</span></span><br><span class="line"><span class="string">    return: 返回哈夫曼编码</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> root.char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        codes[root.char] = current_code  <span class="comment"># 如果是叶子节点则为该字符分配编码</span></span><br><span class="line">        <span class="keyword">return</span> codes</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归构建左子树的编码，路径加0</span></span><br><span class="line">    build_huffman_codes(root.left, current_code + <span class="string">&quot;0&quot;</span>, codes)</span><br><span class="line">    <span class="comment"># 递归构建右子树的编码，路径加1</span></span><br><span class="line">    build_huffman_codes(root.right, current_code + <span class="string">&quot;1&quot;</span>, codes)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> codes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 哈夫曼编码的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">huffman_encoding</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param text:需要进行哈夫曼编码的文本</span></span><br><span class="line"><span class="string">    return:返回编码后的文本和编码字典</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    root = build_huffman_tree(text)  <span class="comment"># 构建哈夫曼树</span></span><br><span class="line">    huffman_codes = build_huffman_codes(root)  <span class="comment"># 构建哈夫曼编码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用哈夫曼编码堆文本进行编码</span></span><br><span class="line">    encoded_text = <span class="string">&quot;&quot;</span>.join(huffman_codes[char] <span class="keyword">for</span> char <span class="keyword">in</span> text)</span><br><span class="line">    <span class="keyword">return</span> encoded_text, huffman_codes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 哈夫曼解码函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">huffman_decoding</span>(<span class="params">encoded_text, huffman_codes</span>):</span><br><span class="line">    reverse_codes = &#123;v: k <span class="keyword">for</span> k, v <span class="keyword">in</span> huffman_codes.items()&#125;</span><br><span class="line"></span><br><span class="line">    current_code = <span class="string">&quot;&quot;</span></span><br><span class="line">    decoded_text = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历解码后的文本</span></span><br><span class="line">    <span class="keyword">for</span> bit <span class="keyword">in</span> encoded_text:</span><br><span class="line">        current_code += bit</span><br><span class="line">        <span class="keyword">if</span> current_code <span class="keyword">in</span> reverse_codes:</span><br><span class="line">            decoded_text += reverse_codes[current_code]  <span class="comment"># 如果编码在反转字典中，则解码字符</span></span><br><span class="line">            current_code = <span class="string">&quot;&quot;</span>  <span class="comment"># 重置当前编码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decoded_text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例文本</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    text = <span class="built_in">input</span>(<span class="string">&quot;请输入一段文本：&quot;</span>)</span><br><span class="line">    encoded_text, huffman_codes = huffman_encoding(text)  <span class="comment"># 编码文本</span></span><br><span class="line">    decoded_text = huffman_decoding(encoded_text, huffman_codes)  <span class="comment"># 解码文本</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出结果</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original text: &quot;</span>, text)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Encoded text: &quot;</span>, encoded_text)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Decoded text: &quot;</span>, decoded_text)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Huffman codes: &quot;</span>, huffman_codes)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性方程组</title>
      <link href="/2024/05/15/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
      <url>/2024/05/15/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h1><p><img src="https://sfile.chatglm.cn/chatglm4/406aef0a-a9bc-41db-aeae-c6ca4ea4ad73.png?image_process=format,webp"></p><hr><h1 id="啥是线性方程组"><a href="#啥是线性方程组" class="headerlink" title="啥是线性方程组"></a>啥是线性方程组</h1><p><img src="https://sfile.chatglm.cn/chatglm4/e90ac349-489a-48ae-8cf1-824042f48cc9.png?image_process=format,webp" alt="img"></p><h1 id="方程组解的情况"><a href="#方程组解的情况" class="headerlink" title="方程组解的情况"></a>方程组解的情况</h1><p><img src="https://sfile.chatglm.cn/chatglm4/8db59fda-ea42-43cf-b847-a690275ebf17.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/4600c720-2e06-4a71-bcb1-538a226b4256.png?image_process=format,webp"></p><h1 id="如何求解方程组"><a href="#如何求解方程组" class="headerlink" title="如何求解方程组"></a>如何求解方程组</h1><p><img src="https://sfile.chatglm.cn/chatglm4/2a295156-2b11-42ab-8f54-b6836d426721.png?image_process=format,webp"></p><ul><li>也有初等列变换，但是初等列变化不是同解变换</li></ul><p><img src="https://sfile.chatglm.cn/chatglm4/fac94418-d400-4123-aa0f-adb9991ff9ac.png?image_process=format,webp"></p><h2 id="行阶梯形矩阵"><a href="#行阶梯形矩阵" class="headerlink" title="行阶梯形矩阵"></a>行阶梯形矩阵</h2><p><img src="https://sfile.chatglm.cn/chatglm4/c3c7575e-72be-4028-b387-ceda62619e20.png?image_process=format,webp"></p><h2 id="行最简型矩阵"><a href="#行最简型矩阵" class="headerlink" title="行最简型矩阵"></a>行最简型矩阵</h2><p><img src="https://sfile.chatglm.cn/chatglm4/8f78e632-1674-4559-874c-d7ae00635074.png?image_process=format,webp"></p><h2 id="秩的定义"><a href="#秩的定义" class="headerlink" title="秩的定义"></a>秩的定义</h2><p><img src="https://sfile.chatglm.cn/chatglm4/2008314b-91bc-4225-acf7-593d91f54fb7.png?image_process=format,webp"></p><h1 id="方程组的求解"><a href="#方程组的求解" class="headerlink" title="方程组的求解"></a>方程组的求解</h1><h2 id="无解"><a href="#无解" class="headerlink" title="无解"></a>无解</h2><ul><li>系数矩阵的秩小于增广矩阵的秩。</li></ul><p><img src="https://sfile.chatglm.cn/chatglm4/169cf10d-2eb9-4b31-9c17-f98a27eed08d.png?image_process=format,webp"></p><h2 id="唯一解"><a href="#唯一解" class="headerlink" title="唯一解"></a>唯一解</h2><ul><li>系数矩阵的秩等于增广矩阵的秩（有解），同时有效方程的个数等于未知数的个数。</li></ul><p><img src="https://sfile.chatglm.cn/chatglm4/334c6175-63c7-4034-b946-ef0258478ea0.png?image_process=format,webp"></p><h2 id="无穷多解："><a href="#无穷多解：" class="headerlink" title="无穷多解："></a>无穷多解：</h2><ul><li>系数矩阵的秩等于增广矩阵的秩（有解），有效方程的个数小于未知数的个数。</li></ul><p><img src="https://sfile.chatglm.cn/chatglm4/370b5c92-f888-4b02-aaf6-b9bcb33907d2.png?image_process=format,webp"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://sfile.chatglm.cn/chatglm4/5e18e7a3-0c03-41b6-a610-f2def478bc2b.png?image_process=format,webp"></p><h1 id="无穷多解的表示问题"><a href="#无穷多解的表示问题" class="headerlink" title="无穷多解的表示问题"></a>无穷多解的表示问题</h1><ul><li>主变量：主元所对应的变量</li><li>自由变量：除了主变量外的所有变量</li></ul><p><img src="https://sfile.chatglm.cn/chatglm4/a79dfab5-a3d9-4a82-a1e5-32a9456228d6.png?image_process=format,webp"></p><h1 id="解方程组流程图"><a href="#解方程组流程图" class="headerlink" title="解方程组流程图"></a>解方程组流程图</h1><p><img src="https://sfile.chatglm.cn/chatglm4/f50f6552-8965-43ae-88d9-4396960ca030.png?image_process=format,webp"></p><h2 id="eg"><a href="#eg" class="headerlink" title="eg"></a>eg</h2><p><img src="https://sfile.chatglm.cn/chatglm4/e69b988e-f5f0-4f5f-9b8e-91f427b7285d.png?image_process=format,webp"></p><h1 id="”齐次“-与-”非齐次“"><a href="#”齐次“-与-”非齐次“" class="headerlink" title="”齐次“ 与 ”非齐次“"></a>”齐次“ 与 ”非齐次“</h1><p><img src="https://sfile.chatglm.cn/chatglm4/84935ed9-e9d7-46f2-9761-11e3e95561c8.png?image_process=format,webp"></p><hr><p><img src="https://sfile.chatglm.cn/chatglm4/696e7372-b4ce-4cd6-8a36-5ad37f2dc340.png?image_process=format,webp"></p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵 </tag>
            
            <tag> 线性方程组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>克拉默法则</title>
      <link href="/2024/05/15/%E5%85%8B%E6%8B%89%E9%BB%98%E6%B3%95%E5%88%99/"/>
      <url>/2024/05/15/%E5%85%8B%E6%8B%89%E9%BB%98%E6%B3%95%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="克拉默法则"><a href="#克拉默法则" class="headerlink" title="克拉默法则"></a>克拉默法则</h1><p><img src="https://sfile.chatglm.cn/chatglm4/26546d12-078e-41f2-9a4c-2179b97410c2.png?image_process=format,webp"></p><hr><h2 id="用行列式解方程组"><a href="#用行列式解方程组" class="headerlink" title="用行列式解方程组"></a>用行列式解方程组</h2><h3 id="二元一次方程组"><a href="#二元一次方程组" class="headerlink" title="二元一次方程组"></a>二元一次方程组</h3><p><img src="https://sfile.chatglm.cn/chatglm4/153a3726-a96d-4c08-a257-c368c93f04b5.png?image_process=format,webp"></p><h3 id="三元一次方程组"><a href="#三元一次方程组" class="headerlink" title="三元一次方程组"></a>三元一次方程组</h3><p><img src="https://sfile.chatglm.cn/chatglm4/618a9710-716e-418f-ba20-d66260fd6404.png?image_process=format,webp"></p><h3 id="n元线性方程组"><a href="#n元线性方程组" class="headerlink" title="n元线性方程组"></a>n元线性方程组</h3><p><img src="https://sfile.chatglm.cn/chatglm4/82d83924-e226-4ee6-927f-309fc76001c4.png?image_process=format,webp"></p><hr><p><img src="https://sfile.chatglm.cn/chatglm4/bcb076bc-45d2-4b32-a82d-824e1e6f71dd.png?image_process=format,webp"></p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵分块法</title>
      <link href="/2024/05/15/%E7%9F%A9%E9%98%B5%E5%88%86%E5%9D%97%E6%B3%95/"/>
      <url>/2024/05/15/%E7%9F%A9%E9%98%B5%E5%88%86%E5%9D%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="矩阵分块法"><a href="#矩阵分块法" class="headerlink" title="矩阵分块法"></a>矩阵分块法</h1><p><img src="https://sfile.chatglm.cn/chatglm4/b69e503d-95a2-4ba9-90b6-822cf64007a0.png?image_process=format,webp"></p><hr><h2 id="矩阵到底咋分块"><a href="#矩阵到底咋分块" class="headerlink" title="矩阵到底咋分块"></a>矩阵到底咋分块</h2><p><img src="https://sfile.chatglm.cn/chatglm4/4d5553c8-8f86-4116-876d-bb2e6fd852b4.png?image_process=format,webp"></p><h2 id="分块矩阵的运算"><a href="#分块矩阵的运算" class="headerlink" title="分块矩阵的运算"></a>分块矩阵的运算</h2><p><img src="https://sfile.chatglm.cn/chatglm4/9545b0fb-33d8-438d-8254-80dca49b421b.png?image_process=format,webp"></p><h2 id="分块矩阵的数乘"><a href="#分块矩阵的数乘" class="headerlink" title="分块矩阵的数乘"></a>分块矩阵的数乘</h2><p><img src="https://sfile.chatglm.cn/chatglm4/dabbe4fe-4331-4418-8674-c52570f9f85c.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/720b49f5-48ce-4c4f-95a1-50946b7d5bc6.png?image_process=format,webp"></p><h2 id="分块矩阵的逆矩阵"><a href="#分块矩阵的逆矩阵" class="headerlink" title="分块矩阵的逆矩阵"></a>分块矩阵的逆矩阵</h2><p><img src="https://sfile.chatglm.cn/chatglm4/43269dbb-ff0a-4b72-81a0-9f6962fd7dcb.png?image_process=format,webp"></p><hr><p><img src="https://sfile.chatglm.cn/chatglm4/bcb076bc-45d2-4b32-a82d-824e1e6f71dd.png?image_process=format,webp"></p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图书整理2</title>
      <link href="/2024/05/06/%E5%9B%BE%E4%B9%A6%E6%95%B4%E7%90%862/"/>
      <url>/2024/05/06/%E5%9B%BE%E4%B9%A6%E6%95%B4%E7%90%862/</url>
      
        <content type="html"><![CDATA[<h1 id="图书整理-II"><a href="#图书整理-II" class="headerlink" title="图书整理 II"></a>图书整理 II</h1><p>读者来到图书馆排队借还书，图书管理员使用两个书车来完成整理借还书的任务。书车中的书从下往上叠加存放，图书管理员每次只能拿取书车顶部的书。排队的读者会有两种操作：</p><ul><li>push(bookID)：把借阅的书籍还到图书馆。</li><li>pop()：从图书馆中借出书籍。</li></ul><p>为了保持图书的顺序，图书管理员每次取出供读者借阅的书籍是 最早 归还到图书馆的书籍。你需要返回 每次读者借出书的值 。</p><p>如果没有归还的书可以取出，返回 -1 。</p><hr><p><strong>示例 1：</strong></p><p>输入：</p><p>[“BookQueue”, “push”, “push”, “pop”]<br>[[], [1], [2], []]</p><p>输出：[null,null,null,1]</p><p>解释：</p><p>MyQueue myQueue &#x3D; new MyQueue();<br>myQueue.push(1); &#x2F;&#x2F; queue is: [1]<br>myQueue.push(2); &#x2F;&#x2F; queue is: [1, 2] (leftmost is front of the queue)<br>myQueue.pop(); &#x2F;&#x2F; return 1, queue is [2]</p><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; bookID &lt;&#x3D; 10000</li><li>最多会对 push、pop 进行 10000 次调用</li></ul><hr><h2 id="队列法"><a href="#队列法" class="headerlink" title="队列法"></a>队列法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 初始化一个列表用于存储队列元素</span></span><br><span class="line">        self.elem = []</span><br><span class="line">        <span class="comment"># 初始化队头指针和队尾指针，队头指针初始为0，队尾指针初始也为0</span></span><br><span class="line">        self.front, self.rear = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># 计算队列的当前大小，由于初始时队头和队尾指针相同，所以大小为0</span></span><br><span class="line">        self.size = self.rear - self.front</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">appendTail</span>(<span class="params">self, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 在队列的尾部添加一个元素</span></span><br><span class="line">        self.elem.append(value)</span><br><span class="line">        <span class="comment"># 队尾指针向后移动一位，表示队列新增了一个元素</span></span><br><span class="line">        self.rear += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 此时不需要更新队头指针，因为队头指针只在删除操作时移动</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteHead</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 如果队头指针和队尾指针相同，表示队列为空</span></span><br><span class="line">        <span class="keyword">if</span> self.front == self.rear:</span><br><span class="line">            <span class="comment"># 抛出异常，因为不能从空队列中删除元素</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 获取队头指针指向的元素，即队列的第一个元素</span></span><br><span class="line">        e = self.elem[self.front]</span><br><span class="line">        <span class="comment"># 队头指针向后移动一位，表示队列删除了一个元素</span></span><br><span class="line">        self.front += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 返回被删除的队头元素</span></span><br><span class="line">        <span class="keyword">return</span> e</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = CQueue()</span></span><br><span class="line"><span class="comment"># obj.appendTail(value)</span></span><br><span class="line"><span class="comment"># param_2 = obj.deleteHead()</span></span><br></pre></td></tr></table></figure><h2 id="双栈法"><a href="#双栈法" class="headerlink" title="双栈法"></a>双栈法</h2><p><lc-slider slides="[{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599286207-iyRyBk-Picture2.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599286207-CGxWnt-Picture3.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599286207-tULpWB-Picture4.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599286207-aEsTfK-Picture5.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599286207-VdXYtf-Picture6.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599286207-heDHcK-Picture7.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599286207-gwMjUh-Picture8.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599286207-xInqcE-Picture9.png&quot;,&quot;duration&quot;:null}]"></lc-slider><div><div><div class="css-hgmg3m-Container e1l4e1yy0"><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1599286207-iyRyBk-Picture2.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1599286207-CGxWnt-Picture3.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1599286207-tULpWB-Picture4.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1599286207-aEsTfK-Picture5.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1599286207-VdXYtf-Picture6.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1599286207-heDHcK-Picture7.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1599286207-gwMjUh-Picture8.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1599286207-xInqcE-Picture9.png"></div><div class="css-y1zd58-Container e2y5b7y0"><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y2 css-2gwest-icon-Button-AutoPlayButton"><defs><path id="play-arrow_svg__a" d="M8 5v14l11-7z"></path><mask id="play-arrow_svg__b"><use fill-rule="evenodd" xlink:href="#play-arrow_svg__a"></use></mask></defs><g fill-rule="evenodd"><use xlink:href="#play-arrow_svg__a"></use><g fill-rule="nonzero" mask="url(#play-arrow_svg__b)"><path d="M0 0h24v24H0z"></path></g></g></svg><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y1 css-bs8j34-icon-Button"><path d="M18 18l-8.5-6L18 6zM8 6v12H6V6z"></path></svg><span class="css-iq4chg-Indicator e2y5b7y3">1 / 8</span><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y1 css-bs8j34-icon-Button"><path d="M6 18l8.5-6L6 6zM16 6v12h2V6z"></path></svg></div></div></div></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 初始化两个栈，一个用于入队（appendTail），一个用于出队（deleteHead）</span></span><br><span class="line">        self.stack_in = []</span><br><span class="line">        self.stack_out = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">appendTail</span>(<span class="params">self, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 将新元素压入入队栈</span></span><br><span class="line">        self.stack_in.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteHead</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 如果出队栈为空，则需要将入队栈的元素倒入出队栈</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack_out:</span><br><span class="line">            <span class="comment"># 如果入队栈也为空，则队列为空，无法执行出队操作</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.stack_in:</span><br><span class="line">                <span class="keyword">raise</span> -<span class="number">1</span></span><br><span class="line">            <span class="comment"># 将入队栈的元素倒入出队栈，注意顺序要颠倒，以保持队列的先进先出特性</span></span><br><span class="line">            <span class="keyword">while</span> self.stack_in:</span><br><span class="line">                self.stack_out.append(self.stack_in.pop())</span><br><span class="line">        <span class="comment"># 出队栈不为空时，直接弹出栈顶元素作为队头元素</span></span><br><span class="line">        <span class="keyword">return</span> self.stack_out.pop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = CQueue()</span></span><br><span class="line"><span class="comment"># obj.appendTail(value)</span></span><br><span class="line"><span class="comment"># param_2 = obj.deleteHead()</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三重积分计算法</title>
      <link href="/2024/05/05/%E4%B8%89%E9%87%8D%E7%A7%AF%E5%88%86%E8%AE%A1%E7%AE%97%E6%B3%95/"/>
      <url>/2024/05/05/%E4%B8%89%E9%87%8D%E7%A7%AF%E5%88%86%E8%AE%A1%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="三重积分计算法"><a href="#三重积分计算法" class="headerlink" title="三重积分计算法"></a>三重积分计算法</h1><p><img src="https://sfile.chatglm.cn/chatglm4/8d51a58e-e4aa-4009-82d0-cb5acebc2327.png?image_process=format,webp"></p><hr><h2 id="如何看懂三重积分"><a href="#如何看懂三重积分" class="headerlink" title="如何看懂三重积分"></a>如何看懂三重积分</h2><p><img src="https://sfile.chatglm.cn/chatglm4/1ff135be-e12d-416a-9584-5cae6f481e12.png?image_process=format,webp"></p><h2 id="用质量理解三重积分"><a href="#用质量理解三重积分" class="headerlink" title="用质量理解三重积分"></a>用质量理解三重积分</h2><p><img src="https://sfile.chatglm.cn/chatglm4/c383fe4b-e741-453a-a379-585db1e147b8.png?image_process=format,webp"></p><h2 id="三重积分的运算性质"><a href="#三重积分的运算性质" class="headerlink" title="三重积分的运算性质"></a>三重积分的运算性质</h2><p><img src="https://sfile.chatglm.cn/chatglm4/25dbd836-6c6f-4a7e-bf2a-0fddde4e1374.png?image_process=format,webp"></p><h2 id="如何计算？"><a href="#如何计算？" class="headerlink" title="如何计算？"></a>如何计算？</h2><p><img src="https://sfile.chatglm.cn/chatglm4/d982e5de-2a65-49c5-a872-19e50ddb9964.png?image_process=format,webp"></p><h2 id="直角坐标系"><a href="#直角坐标系" class="headerlink" title="直角坐标系"></a>直角坐标系</h2><h3 id="先一后二"><a href="#先一后二" class="headerlink" title="先一后二"></a>先一后二</h3><p><img src="https://sfile.chatglm.cn/chatglm4/07bd2d6e-1bbd-4d21-8acd-f371021a1895.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/c5baabd7-3c9d-44c3-89f1-3c6c51066cea.png?image_process=format,webp"></p><h3 id="eg1"><a href="#eg1" class="headerlink" title="eg1"></a>eg1</h3><p><img src="https://sfile.chatglm.cn/chatglm4/4c76f19f-b239-46ab-be53-c0fcaf804762.png?image_process=format,webp"></p><h3 id="先二后一"><a href="#先二后一" class="headerlink" title="先二后一"></a>先二后一</h3><p><img src="https://sfile.chatglm.cn/chatglm4/2701602d-9f29-4e47-b866-5df05770fb80.png?image_process=format,webp"></p><h3 id="eg2"><a href="#eg2" class="headerlink" title="eg2"></a>eg2</h3><p><img src="https://sfile.chatglm.cn/chatglm4/2580f99f-2743-4d5f-80b7-9aaf59dad1fb.png?image_process=format,webp"></p><h2 id="柱面坐标系"><a href="#柱面坐标系" class="headerlink" title="柱面坐标系"></a>柱面坐标系</h2><p><img src="https://sfile.chatglm.cn/chatglm4/f21e2467-9bd2-43e7-a5be-5b11c7bada18.png?image_process=format,webp"></p><h3 id="eg3"><a href="#eg3" class="headerlink" title="eg3"></a>eg3</h3><h4 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h4><p><img src="https://sfile.chatglm.cn/chatglm4/3b0ebe5f-8599-4d6b-86e1-6aa8a1e5c090.png?image_process=format,webp"></p><h4 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h4><p><img src="https://sfile.chatglm.cn/chatglm4/735d0cee-6e62-4966-adad-040e5c09f903.png?image_process=format,webp"></p><h2 id="球面坐标系"><a href="#球面坐标系" class="headerlink" title="球面坐标系"></a>球面坐标系</h2><p><img src="https://sfile.chatglm.cn/chatglm4/514a17a6-6b55-4303-9254-b5a22521024e.png?image_process=format,webp"></p><h3 id="三重积分的轮换对称性"><a href="#三重积分的轮换对称性" class="headerlink" title="三重积分的轮换对称性"></a>三重积分的轮换对称性</h3><p><img src="https://sfile.chatglm.cn/chatglm4/79f79937-0a3d-43b0-a256-497530af58cf.png?image_process=format,webp"></p><h3 id="eg4"><a href="#eg4" class="headerlink" title="eg4"></a>eg4</h3><p><img src="https://sfile.chatglm.cn/chatglm4/4fdcedbf-f954-4cf2-b074-4073ad904f47.png?image_process=format,webp"></p><h3 id="三重积分的普通对称性"><a href="#三重积分的普通对称性" class="headerlink" title="三重积分的普通对称性"></a>三重积分的普通对称性</h3><p><img src="https://sfile.chatglm.cn/chatglm4/ba9d198d-2144-4251-86f0-c440562715f6.png?image_process=format,webp"></p><h3 id="eg5"><a href="#eg5" class="headerlink" title="eg5"></a>eg5</h3><p><img src="https://sfile.chatglm.cn/chatglm4/498a3d77-70c5-41fc-bc50-135e976bac99.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/cbb07b4b-9596-4d76-a098-4914f55b5c12.png?image_process=format,webp"></p><hr><h2 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h2><p><img src="https://sfile.chatglm.cn/chatglm4/084cc816-ec4c-4970-b87c-b6932a46c62e.png?image_process=format,webp"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://sfile.chatglm.cn/chatglm4/0f02fef8-456d-40b6-8115-3080a22ae0bb.png?image_process=format,webp"></p>]]></content>
      
      
      <categories>
          
          <category> 积分学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汽车价格多元线性回归</title>
      <link href="/2024/05/05/%E6%B1%BD%E8%BD%A6%E4%BB%B7%E6%A0%BC%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
      <url>/2024/05/05/%E6%B1%BD%E8%BD%A6%E4%BB%B7%E6%A0%BC%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="汽车价格预测多元线性回归"><a href="#汽车价格预测多元线性回归" class="headerlink" title="汽车价格预测多元线性回归"></a>汽车价格预测多元线性回归</h1><h2 id="关于数据集"><a href="#关于数据集" class="headerlink" title="关于数据集"></a>关于数据集</h2><h3 id="问题陈述"><a href="#问题陈述" class="headerlink" title="问题陈述"></a>问题陈述</h3><p>一家中国汽车公司吉利汽车渴望进入美国市场，在美利建立制造工厂并在当地生产汽车，以与美国和欧洲同行竞争。</p><p>他们与一家汽车咨询公司签订了合同，以了解汽车定价所依赖的因素。具体来说，他们希望了解影响美国市场汽车定价的因素，因为这些因素可能与中国市场有很大不同。公司想知道：</p><p>哪些变量在预测汽车<br>价格方面具有重要意义 这些变量对汽车<br>价格的描述程度 根据各种市场调查，该咨询公司收集了美国市场上不同类型汽车的大量数据集。</p><h3 id="业务目标"><a href="#业务目标" class="headerlink" title="业务目标"></a>业务目标</h3><p>我们需要使用可用的自变量对汽车价格进行建模。管理层将使用它来了解价格如何随自变量而变化。因此，他们可以操纵汽车的设计、商业战略等，以满足一定的价格水平。此外，该模型将是管理层了解新市场定价动态的好方法。</p><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> TensorDataset, DataLoader</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.optim <span class="keyword">import</span> SGD</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数设置</span></span><br><span class="line">file_path = <span class="string">r&#x27;D:\ALL_code\al_study_file\al_study\MachineLearning\线性回归\car-price-prediction\CarPrice_Assignment.csv&#x27;</span></span><br><span class="line">batch_size = <span class="number">2</span></span><br><span class="line">num_epochs = <span class="number">100</span></span><br><span class="line">lr = <span class="number">0.001</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据预处理</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preprocess_data</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="comment"># 读取CSV文件</span></span><br><span class="line">    data_arrays = pd.read_csv(file_path)</span><br><span class="line">    <span class="comment"># 找到非数值列</span></span><br><span class="line">    non_numeric_columns = data_arrays.select_dtypes(include=[<span class="string">&quot;object&quot;</span>, <span class="string">&quot;category&quot;</span>]).columns.tolist()</span><br><span class="line">    <span class="comment"># 使用get_dummies进行独热编码</span></span><br><span class="line">    data_encoded = pd.get_dummies(data_arrays, columns=non_numeric_columns)</span><br><span class="line">    <span class="comment"># 保存均值和标准差</span></span><br><span class="line">    mean = data_encoded.mean()</span><br><span class="line">    std = data_encoded.std()</span><br><span class="line">    <span class="comment"># 数据标准化</span></span><br><span class="line">    data_encoded = (data_encoded - mean) / std</span><br><span class="line">    <span class="comment"># 分离特征和标签</span></span><br><span class="line">    features = data_encoded.drop([<span class="string">&#x27;price&#x27;</span>, <span class="string">&#x27;car_ID&#x27;</span>], axis=<span class="number">1</span>)</span><br><span class="line">    labels = data_encoded[<span class="string">&#x27;price&#x27;</span>]</span><br><span class="line">    <span class="comment"># 转换为PyTorch Tensor</span></span><br><span class="line">    features = torch.tensor(features.values, dtype=torch.float32)</span><br><span class="line">    labels = torch.tensor(labels.values, dtype=torch.float32).unsqueeze(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> features, labels, mean, std</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造数据迭代器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_array</span>(<span class="params">data_arrays, batch_size, is_train=<span class="literal">True</span></span>):</span><br><span class="line">    dataset = TensorDataset(*data_arrays)</span><br><span class="line">    <span class="keyword">return</span> DataLoader(dataset, batch_size, shuffle=is_train)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinearRegression</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_dim</span>):</span><br><span class="line">        <span class="built_in">super</span>(LinearRegression, self).__init__()</span><br><span class="line">        self.layer = nn.Linear(input_dim, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.layer(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_model</span>(<span class="params">net, features, labels, batch_size, num_epochs, lr</span>):</span><br><span class="line">    <span class="comment"># 创建训练数据迭代器</span></span><br><span class="line">    data_iter = load_array((features, labels), batch_size)</span><br><span class="line">    <span class="comment"># 初始化模型参数</span></span><br><span class="line">    net.layer.weight.data.normal_(<span class="number">0</span>, <span class="number">0.01</span>)</span><br><span class="line">    net.layer.bias.data.fill_(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 损失函数和优化器</span></span><br><span class="line">    loss = nn.MSELoss()</span><br><span class="line">    trainer = SGD(net.parameters(), lr=lr)</span><br><span class="line">    <span class="comment"># 存储每个epoch的损失值</span></span><br><span class="line">    loss_history = []</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">            l = loss(net(X), y)</span><br><span class="line">            trainer.zero_grad()</span><br><span class="line">            l.backward()</span><br><span class="line">            trainer.step()</span><br><span class="line">        <span class="comment"># 计算并记录当前epoch的总损失</span></span><br><span class="line">        l = loss(net(features), labels)</span><br><span class="line">        loss_history.append(l.item())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;l.item():f&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> loss_history</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化损失</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visualize_loss</span>(<span class="params">loss_history</span>):</span><br><span class="line">    plt.plot(<span class="built_in">range</span>(<span class="number">1</span>, num_epochs + <span class="number">1</span>), loss_history)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Training Loss&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 数据预处理</span></span><br><span class="line">    features, labels, mean, std = preprocess_data(file_path)</span><br><span class="line">    <span class="comment"># 定义模型</span></span><br><span class="line">    net = LinearRegression(features.shape[<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 训练模型</span></span><br><span class="line">    loss_history = train_model(net, features, labels, batch_size, num_epochs, lr)</span><br><span class="line">    <span class="comment"># 可视化损失</span></span><br><span class="line">    visualize_loss(loss_history)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="可视化结果"><a href="#可视化结果" class="headerlink" title="可视化结果"></a>可视化结果</h3><p><img src="https://sfile.chatglm.cn/chatglm4/98af265e-7372-47a8-a923-bd32cf5d2a5a.png?image_process=format,webp"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>训练计划5</title>
      <link href="/2024/05/05/%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%925/"/>
      <url>/2024/05/05/%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%925/</url>
      
        <content type="html"><![CDATA[<h1 id="训练计划-V"><a href="#训练计划-V" class="headerlink" title="训练计划 V"></a>训练计划 V</h1><p>某教练同时带教两位学员，分别以链表 l1、l2 记录了两套核心肌群训练计划，节点值为训练项目编号。两套计划仅有前半部分热身项目不同，后续正式训练项目相同。请设计一个程序找出并返回第一个正式训练项目编号。如果两个链表不存在相交节点，返回 null 。</p><p>如下面的两个链表：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"></p><p>在节点 c1 开始相交。</p><p><strong>输入说明：</strong></p><p>intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0</p><p>l1 - 第一个训练计划链表</p><p>l2 - 第二个训练计划链表</p><p>skip1 - 在 l1 中（从头节点开始）跳到交叉节点的节点数</p><p>skip2 - 在 l2 中（从头节点开始）跳到交叉节点的节点数</p><p>程序将根据这些输入创建链式数据结构，并将两个头节点 head1 和 head2 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被视作正确答案 。</p><hr><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png"></p><p>输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3<br>输出：Reference of the node with value &#x3D; 8<br>解释：第一个正式训练项目编号为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png"></p><p>输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1<br>输出：Reference of the node with value &#x3D; 2<br>解释：第一个正式训练项目编号为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png"></p><p>输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2<br>输出：null<br>解释：两套计划完全不同，返回 null。从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</p><p><strong>注意：</strong></p><p>如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p><hr><h2 id="尾相同法"><a href="#尾相同法" class="headerlink" title="尾相同法"></a>尾相同法</h2><p><lc-slider slides="[{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1615224578-lFxRVR-Picture2.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1615224578-atzfoi-Picture3.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1615224578-QvNyxe-Picture4.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1615224578-zPMkyB-Picture5.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1615224578-MRfzKN-Picture6.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1615224578-UIHyvx-Picture7.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1615224578-fyOdzW-Picture8.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1615224578-LcVJxI-Picture9.png&quot;,&quot;duration&quot;:null}]"></lc-slider><div><div><div class="css-hgmg3m-Container e1l4e1yy0"><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1615224578-lFxRVR-Picture2.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1615224578-atzfoi-Picture3.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1615224578-QvNyxe-Picture4.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1615224578-zPMkyB-Picture5.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1615224578-MRfzKN-Picture6.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1615224578-UIHyvx-Picture7.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1615224578-fyOdzW-Picture8.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1615224578-LcVJxI-Picture9.png"></div><div class="css-y1zd58-Container e2y5b7y0"><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y2 css-2gwest-icon-Button-AutoPlayButton"><defs><path id="play-arrow_svg__a" d="M8 5v14l11-7z"></path><mask id="play-arrow_svg__b"><use fill-rule="evenodd" xlink:href="#play-arrow_svg__a"></use></mask></defs><g fill-rule="evenodd"><use xlink:href="#play-arrow_svg__a"></use><g fill-rule="nonzero" mask="url(#play-arrow_svg__b)"><path d="M0 0h24v24H0z"></path></g></g></svg><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y1 css-bs8j34-icon-Button"><path d="M18 18l-8.5-6L18 6zM8 6v12H6V6z"></path></svg><span class="css-iq4chg-Indicator e2y5b7y3">1 / 8</span><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y1 css-bs8j34-icon-Button"><path d="M6 18l8.5-6L6 6zM16 6v12h2V6z"></path></svg></div></div></div></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="comment"># 初始化两个指针</span></span><br><span class="line">        pA, pB = headA, headB</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历两个链表，直到它们相遇</span></span><br><span class="line">        <span class="keyword">while</span> pA <span class="keyword">is</span> <span class="keyword">not</span> pB:</span><br><span class="line">            <span class="comment"># 如果pA到达链表末尾，将其移动到headB</span></span><br><span class="line">            pA = pA.<span class="built_in">next</span> <span class="keyword">if</span> pA <span class="keyword">else</span> headB</span><br><span class="line">            <span class="comment"># 如果pB到达链表末尾，将其移动到headA</span></span><br><span class="line">            pB = pB.<span class="built_in">next</span> <span class="keyword">if</span> pB <span class="keyword">else</span> headA</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 返回相交节点</span></span><br><span class="line">        <span class="keyword">return</span> pA</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>训练计划4</title>
      <link href="/2024/05/05/%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%924/"/>
      <url>/2024/05/05/%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%924/</url>
      
        <content type="html"><![CDATA[<h1 id="训练计划-IV"><a href="#训练计划-IV" class="headerlink" title="训练计划 IV"></a>训练计划 IV</h1><p>给定两个以<strong>有序链表</strong>形式记录的训练计划<code>l1、l2</code>分别记录了两套核心肌群训练项目编号，请合并这两个训练计划，按训练项目编号<strong>升序</strong>记录于链表并返回。</p><p><strong>注意</strong>：新链表是通过拼接给定的两个链表的所有节点组成的。</p><hr><p><strong>示例 1：</strong></p><p>输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]<br>输出：[1,1,2,3,4,4]</p><p><strong>示例 2：</strong></p><p>输入：l1 &#x3D; [], l2 &#x3D; []<br>输出：[]</p><p><strong>示例 3：</strong></p><p>输入：l1 &#x3D; [], l2 &#x3D; [0]<br>输出：[0]</p><p><strong>提示：</strong></p><p>$0 &lt;&#x3D; 链表长度 &lt;&#x3D; 1000$</p><hr><h2 id="伪头节点"><a href="#伪头节点" class="headerlink" title="伪头节点"></a>伪头节点</h2><p><lc-slider slides="[{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/05455e3fb731d5a7648e37c8c8457b0ceb150de3b0527a78f634b7a860c18027-Picture3.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/e3ffa4ba33af05fcf44ea49f25c9e60aef5b3c3d3354153a28e4bfa4d1dc8efc-Picture4.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/9129290dd20a1e08204ee2163827d1a8221504e793925706bd222c2bf6c0cf73-Picture5.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/9f8886d4cee6c5388bf0bd6fb10cbdf221cda2d5ef0658cafd59b5ee40b8cf76-Picture6.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/cb95607fe27ce4d33f0be29e3654fb493b3ef30a021b873224557e653b25c83e-Picture7.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/2522ef8e15165bf431023944c21415aacdd5bb5f3a326e054afe719f381a5b7c-Picture8.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/847b824db3b595061ef654d4f0371df28e7a8f1c659c171599272aab737b0aff-Picture9.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/37df2fe55b9cb1f1014a545a5342a1612f7960c45058cc2ed1c11126008c2e76-Picture10.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/07fd5c0b5fca93187466b8243dd43a16eed603c53a3e6582b7e7eaa1fe32c74c-Picture11.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/3b7c0eb170a0cbcb6b82f3f1f8d6847edaaa9a7a92c3cb7a6c7c2e48f5fa8e9f-Picture12.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/a205af9de048c533b61719f86f64b3df6b91ad3b61343d6111439dca86e65110-Picture13.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/a92a8e0154079d0aafed45c6a5a5f72079bf05c2246c9655f9c7e593eaebdaf1-Picture14.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/e3f9ea9e458d4fbe1e79002648df4b317c14a56426baa3b417078ead13b1537b-Picture15.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/16d64263051da9ac16aafec27694f8c925c5f4f0cc854e494ce21b3065f4411f-Picture16.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/e6716316657e534835459fb5c3df99c5b8873da3a67af1eb1b9e27837245087e-Picture17.png&quot;,&quot;duration&quot;:null}]"></lc-slider><div><div><div class="css-hgmg3m-Container e1l4e1yy0"><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/05455e3fb731d5a7648e37c8c8457b0ceb150de3b0527a78f634b7a860c18027-Picture3.png" hidden=""><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/e3ffa4ba33af05fcf44ea49f25c9e60aef5b3c3d3354153a28e4bfa4d1dc8efc-Picture4.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/9129290dd20a1e08204ee2163827d1a8221504e793925706bd222c2bf6c0cf73-Picture5.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/9f8886d4cee6c5388bf0bd6fb10cbdf221cda2d5ef0658cafd59b5ee40b8cf76-Picture6.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/cb95607fe27ce4d33f0be29e3654fb493b3ef30a021b873224557e653b25c83e-Picture7.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/2522ef8e15165bf431023944c21415aacdd5bb5f3a326e054afe719f381a5b7c-Picture8.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/847b824db3b595061ef654d4f0371df28e7a8f1c659c171599272aab737b0aff-Picture9.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/37df2fe55b9cb1f1014a545a5342a1612f7960c45058cc2ed1c11126008c2e76-Picture10.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/07fd5c0b5fca93187466b8243dd43a16eed603c53a3e6582b7e7eaa1fe32c74c-Picture11.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/3b7c0eb170a0cbcb6b82f3f1f8d6847edaaa9a7a92c3cb7a6c7c2e48f5fa8e9f-Picture12.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/a205af9de048c533b61719f86f64b3df6b91ad3b61343d6111439dca86e65110-Picture13.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/a92a8e0154079d0aafed45c6a5a5f72079bf05c2246c9655f9c7e593eaebdaf1-Picture14.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/e3f9ea9e458d4fbe1e79002648df4b317c14a56426baa3b417078ead13b1537b-Picture15.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/16d64263051da9ac16aafec27694f8c925c5f4f0cc854e494ce21b3065f4411f-Picture16.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/e6716316657e534835459fb5c3df99c5b8873da3a67af1eb1b9e27837245087e-Picture17.png"></div><div class="css-y1zd58-Container e2y5b7y0"><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y2 css-2gwest-icon-Button-AutoPlayButton"><defs><path id="play-arrow_svg__a" d="M8 5v14l11-7z"></path><mask id="play-arrow_svg__b"><use fill-rule="evenodd" xlink:href="#play-arrow_svg__a"></use></mask></defs><g fill-rule="evenodd"><use xlink:href="#play-arrow_svg__a"></use><g fill-rule="nonzero" mask="url(#play-arrow_svg__b)"><path d="M0 0h24v24H0z"></path></g></g></svg><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y1 css-bs8j34-icon-Button"><path d="M18 18l-8.5-6L18 6zM8 6v12H6V6z"></path></svg><span class="css-iq4chg-Indicator e2y5b7y3">2 / 15</span><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y1 css-bs8j34-icon-Button"><path d="M6 18l8.5-6L6 6zM16 6v12h2V6z"></path></svg></div></div></div></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义单链表的节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val  <span class="comment"># 节点存储的值</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span>  <span class="comment"># 指向下一个节点的引用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义解决链表问题的解决方案类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trainningPlan</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 创建一个辅助头节点，用于简化链表操作</span></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 初始化当前节点为辅助头节点，用于构建新的链表</span></span><br><span class="line">        current = dummy</span><br><span class="line">        <span class="comment"># 当两个链表都不为空时，比较它们的值</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="comment"># 如果l1的值小于l2的值，将l1的当前节点添加到新链表中</span></span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                current.<span class="built_in">next</span> = l1</span><br><span class="line">                l1 = l1.<span class="built_in">next</span>  <span class="comment"># l1指向下一个节点</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 否则，将l2的当前节点添加到新链表中</span></span><br><span class="line">                current.<span class="built_in">next</span> = l2</span><br><span class="line">                l2 = l2.<span class="built_in">next</span>  <span class="comment"># l2指向下一个节点</span></span><br><span class="line">            current = current.<span class="built_in">next</span>  <span class="comment"># 新链表的当前节点指向下一个节点</span></span><br><span class="line">        <span class="comment"># 如果l1还有剩余节点，将它们添加到结果链表中</span></span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            current.<span class="built_in">next</span> = l1</span><br><span class="line">        <span class="comment"># 如果l2还有剩余节点，将它们添加到结果链表中</span></span><br><span class="line">        <span class="keyword">elif</span> l2:</span><br><span class="line">            current.<span class="built_in">next</span> = l2</span><br><span class="line">        <span class="comment"># 返回辅助头节点的下一个节点，即合并后链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序入口</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="comment"># 创建链表l1</span></span><br><span class="line">    l1 = ListNode(<span class="number">1</span>)</span><br><span class="line">    l1.<span class="built_in">next</span> = ListNode(<span class="number">2</span>)</span><br><span class="line">    l1.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">4</span>)</span><br><span class="line">    <span class="comment"># 创建链表l2</span></span><br><span class="line">    l2 = ListNode(<span class="number">1</span>)</span><br><span class="line">    l2.<span class="built_in">next</span> = ListNode(<span class="number">3</span>)</span><br><span class="line">    l2.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">4</span>)</span><br><span class="line">    <span class="comment"># 合并两个链表</span></span><br><span class="line">    new_l = s.trainningPlan(l1, l2)</span><br><span class="line">    <span class="comment"># 打印合并后的链表</span></span><br><span class="line">    <span class="keyword">while</span> new_l:</span><br><span class="line">        <span class="built_in">print</span>(new_l.val)</span><br><span class="line">        new_l = new_l.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 伪头节点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>训练计划2</title>
      <link href="/2024/05/05/%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%922/"/>
      <url>/2024/05/05/%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%922/</url>
      
        <content type="html"><![CDATA[<h1 id="训练计划-II"><a href="#训练计划-II" class="headerlink" title="训练计划 II"></a>训练计划 II</h1><p>给定一个头节点为 head 的链表用于记录一系列核心肌群训练项目编号，请查找并返回倒数第 cnt 个训练项目编号。</p><hr><p><strong>示例 1：</strong></p><p>输入：head &#x3D; [2,4,7,8], cnt &#x3D; 1<br>输出：8</p><p><strong>提示：</strong></p><p>$1 &lt;&#x3D; head.length &lt;&#x3D; 100$<br>$0 &lt;&#x3D; head[i] &lt;&#x3D; 100$<br>$1 &lt;&#x3D; cnt &lt;&#x3D; head.length$</p><hr><h2 id="初版"><a href="#初版" class="headerlink" title="初版"></a>初版</h2><p><img src="https://pic.leetcode-cn.com/1600794523-AAMvoP-Picture1.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># 定义单链表的节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val  <span class="comment"># 节点存储的值</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span>  <span class="comment"># 指向下一个节点的引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义解决链表问题的解决方案类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trainingPlan</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], cnt: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 初始化链表长度为0</span></span><br><span class="line">        len_ = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 初始化当前节点为头节点</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="comment"># 遍历链表计算长度</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            len_ += <span class="number">1</span>  <span class="comment"># 长度增加1</span></span><br><span class="line">            head = head.<span class="built_in">next</span>  <span class="comment"># 移动到下一个节点</span></span><br><span class="line">        <span class="comment"># 计算倒数第cnt个节点的位置，n为倒数第cnt个节点在正序中的位置</span></span><br><span class="line">        n = len_ - cnt</span><br><span class="line">        <span class="comment"># 从头节点开始，移动到倒数第cnt个节点的前一个节点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 返回倒数第cnt个节点</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><h2 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h2><p><lc-slider slides="[{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1600794523-rIzxRa-Picture2.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1600794523-uBYNOH-Picture3.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1600794523-DUsoIo-Picture4.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1600794523-KeuJNd-Picture5.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1600794523-wGInQX-Picture6.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1600794523-zzxWkh-Picture7.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1600794523-NHOoqg-Picture8.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1600794523-vBjirm-Picture9.png&quot;,&quot;duration&quot;:null}]"></lc-slider><div><div><div class="css-hgmg3m-Container e1l4e1yy0"><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1600794523-rIzxRa-Picture2.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1600794523-uBYNOH-Picture3.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1600794523-DUsoIo-Picture4.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1600794523-KeuJNd-Picture5.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1600794523-wGInQX-Picture6.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1600794523-zzxWkh-Picture7.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1600794523-NHOoqg-Picture8.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1600794523-vBjirm-Picture9.png"></div><div class="css-y1zd58-Container e2y5b7y0"><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y2 css-2gwest-icon-Button-AutoPlayButton"><defs><path id="play-arrow_svg__a" d="M8 5v14l11-7z"></path><mask id="play-arrow_svg__b"><use fill-rule="evenodd" xlink:href="#play-arrow_svg__a"></use></mask></defs><g fill-rule="evenodd"><use xlink:href="#play-arrow_svg__a"></use><g fill-rule="nonzero" mask="url(#play-arrow_svg__b)"><path d="M0 0h24v24H0z"></path></g></g></svg><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y1 css-bs8j34-icon-Button"><path d="M18 18l-8.5-6L18 6zM8 6v12H6V6z"></path></svg><span class="css-iq4chg-Indicator e2y5b7y3">1 / 8</span><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y1 css-bs8j34-icon-Button"><path d="M6 18l8.5-6L6 6zM16 6v12h2V6z"></path></svg></div></div></div></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义单链表的节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val  <span class="comment"># 节点存储的值</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span>  <span class="comment"># 指向下一个节点的引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义解决链表问题的解决方案类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trainingPlan</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], cnt: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 初始化两个指针，都指向头节点</span></span><br><span class="line">        former, later = head, head</span><br><span class="line">        <span class="comment"># 将former指针向前移动cnt个位置</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(cnt):</span><br><span class="line">            former = former.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 当former指针没有到达链表末尾时，继续移动两个指针</span></span><br><span class="line">        <span class="keyword">while</span> former:</span><br><span class="line">            former, later = former.<span class="built_in">next</span>, later.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 当former指针到达链表末尾时，later指针指向的就是倒数第cnt个节点</span></span><br><span class="line">        <span class="keyword">return</span> later</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>训练计划3</title>
      <link href="/2024/05/04/%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%923/"/>
      <url>/2024/05/04/%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%923/</url>
      
        <content type="html"><![CDATA[<h1 id="训练计划-III"><a href="#训练计划-III" class="headerlink" title="训练计划 III"></a>训练计划 III</h1><p>给定一个头节点为 head 的单链表用于记录一系列核心肌群训练编号，请将该系列训练编号 倒序 记录于链表并返回。</p><hr><p><strong>示例 1：</strong></p><p>输入：head &#x3D; [1,2,3,4,5]<br>输出：[5,4,3,2,1]</p><p><strong>示例 2：</strong></p><p>输入：head &#x3D; [1,2]<br>输出：[2,1]</p><p><strong>示例 3：</strong></p><p>输入：head &#x3D; []<br>输出：[]</p><p><strong>提示：</strong></p><p>链表中节点的数目范围是<code>[0, 5000]</code><br><code>-5000 &lt;= Node.val &lt;= 5000</code></p><hr><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p><lc-slider slides="[{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1604779288-fMPcDn-Picture2.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1604779288-jExDGV-Picture3.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1604779444-fENrGT-Picture4.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1604779288-GaydTj-Picture5.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1604779288-gowIkz-Picture6.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1604779288-VWjYQd-Picture7.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1604779288-DyVPZm-Picture8.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1604779288-yyhJIv-Picture9.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1604779288-nZLbad-Picture10.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1604779288-OLQNEW-Picture11.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1604779288-MHParU-Picture12.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1604779288-CaAUfb-Picture13.png&quot;,&quot;duration&quot;:null}]"></lc-slider><div><div><div class="css-hgmg3m-Container e1l4e1yy0"><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1604779288-fMPcDn-Picture2.png" hidden=""><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1604779288-jExDGV-Picture3.png" hidden=""><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1604779444-fENrGT-Picture4.png" hidden=""><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1604779288-GaydTj-Picture5.png" hidden=""><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1604779288-gowIkz-Picture6.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1604779288-VWjYQd-Picture7.png" hidden=""><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1604779288-DyVPZm-Picture8.png" hidden=""><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1604779288-yyhJIv-Picture9.png" hidden=""><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1604779288-nZLbad-Picture10.png" hidden=""><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1604779288-OLQNEW-Picture11.png" hidden=""><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1604779288-MHParU-Picture12.png" hidden=""><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1604779288-CaAUfb-Picture13.png" hidden=""></div><div class="css-y1zd58-Container e2y5b7y0"><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y2 css-2gwest-icon-Button-AutoPlayButton"><path d="M6 19h4V5H6zm8-14v14h4V5z"></path></svg><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y1 css-bs8j34-icon-Button"><path d="M18 18l-8.5-6L18 6zM8 6v12H6V6z"></path></svg><span class="css-iq4chg-Indicator e2y5b7y3">5 / 12</span><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y1 css-bs8j34-icon-Button"><path d="M6 18l8.5-6L6 6zM16 6v12h2V6z"></path></svg></div></div></div></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trainningPlan</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        current = head</span><br><span class="line">        <span class="comment"># 使用 current 作为循环条件，而不是 head</span></span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            next_node = current.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = current</span><br><span class="line">            current = next_node</span><br><span class="line">        <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><lc-slider slides="[{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1604779288-qqLwjR-Picture14.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1604779288-ZENdRv-Picture15.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1604779288-seTNVj-Picture16.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1604779288-sLdyLs-Picture17.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1604779288-jxqzsM-Picture18.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1604779288-ezRpYf-Picture19.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1604779288-CupRFr-Picture20.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1604779288-fEyTvV-Picture21.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1604779288-ZoKASJ-Picture22.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1604779700-EVamXi-Picture23.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1604779700-APVBqI-Picture24.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1604779700-zBKSUx-Picture25.png&quot;,&quot;duration&quot;:null}]"></lc-slider><div><div><div class="css-hgmg3m-Container e1l4e1yy0"><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1604779288-qqLwjR-Picture14.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1604779288-ZENdRv-Picture15.png" hidden=""><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1604779288-seTNVj-Picture16.png" hidden=""><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1604779288-sLdyLs-Picture17.png" hidden=""><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1604779288-jxqzsM-Picture18.png" hidden=""><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1604779288-ezRpYf-Picture19.png" hidden=""><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1604779288-CupRFr-Picture20.png" hidden=""><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1604779288-fEyTvV-Picture21.png" hidden=""><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1604779288-ZoKASJ-Picture22.png" hidden=""><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1604779700-EVamXi-Picture23.png" hidden=""><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1604779700-APVBqI-Picture24.png" hidden=""><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1604779700-zBKSUx-Picture25.png" hidden=""></div><div class="css-y1zd58-Container e2y5b7y0"><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y2 css-2gwest-icon-Button-AutoPlayButton"><defs><path id="play-arrow_svg__a" d="M8 5v14l11-7z"></path><mask id="play-arrow_svg__b"><use fill-rule="evenodd" xlink:href="#play-arrow_svg__a"></use></mask></defs><g fill-rule="evenodd"><use xlink:href="#play-arrow_svg__a"></use><g fill-rule="nonzero" mask="url(#play-arrow_svg__b)"><path d="M0 0h24v24H0z"></path></g></g></svg><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y1 css-bs8j34-icon-Button" style=""><path d="M18 18l-8.5-6L18 6zM8 6v12H6V6z"></path></svg><span class="css-iq4chg-Indicator e2y5b7y3">1 / 12</span><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y1 css-bs8j34-icon-Button"><path d="M6 18l8.5-6L6 6zM16 6v12h2V6z"></path></svg></div></div></div></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trainningPlan</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 定义一个递归函数，接受当前节点和前一个节点作为参数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">recur</span>(<span class="params">current, prev</span>):</span><br><span class="line">            <span class="comment"># 如果当前节点为空，说明已经到达原链表的末尾，返回前一个节点作为新链表的头节点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> current:</span><br><span class="line">                <span class="keyword">return</span> prev</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 递归调用，处理当前节点的下一个节点，并将当前节点作为递归调用中的前一个节点</span></span><br><span class="line">                res = recur(current.<span class="built_in">next</span>, current)</span><br><span class="line">                <span class="comment"># 修改当前节点的next指针，使其指向前一个节点，实现反转</span></span><br><span class="line">                current.<span class="built_in">next</span> = prev</span><br><span class="line">                <span class="comment"># 返回反转链表的头节点，这个值在递归的最深层被第一次返回，并在每次递归返回时逐步向上传递</span></span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调用递归函数，初始时，当前节点为链表的头节点，前一个节点为None</span></span><br><span class="line">        <span class="keyword">return</span> recur(head, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除链表中的节点</title>
      <link href="/2024/05/04/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
      <url>/2024/05/04/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="删除链表节点"><a href="#删除链表节点" class="headerlink" title="删除链表节点"></a>删除链表节点</h1><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><hr><p><strong>示例 1:</strong> </p><p>输入: head &#x3D; [4,5,1,9], val &#x3D; 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p><p><strong>示例 2:</strong></p><p>输入: head &#x3D; [4,5,1,9], val &#x3D; 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p><p><strong>说明：</strong></p><p>题目保证链表中节点的值互不相同<br>若使用 C 或 C++ 语言，你不需要<code>free</code>或<code>delete</code>被删除的节点</p><hr><h2 id="初版"><a href="#初版" class="headerlink" title="初版"></a>初版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, head: ListNode, val: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="comment"># 检查头部节点是否为要删除的节点</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">and</span> head.val == val:</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 如果链表为空或所有节点都被删除，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始化当前节点为头部</span></span><br><span class="line">        curr = head</span><br><span class="line">        <span class="comment"># 遍历链表，寻找要删除的节点</span></span><br><span class="line">        <span class="keyword">while</span> curr.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> curr.<span class="built_in">next</span>.val == val:</span><br><span class="line">                <span class="comment"># 删除节点</span></span><br><span class="line">                curr.<span class="built_in">next</span> = curr.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 移动到下一个节点</span></span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h2><p><img src="https://pic.leetcode-cn.com/1613757478-NBOvjn-Picture1.png"></p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p><lc-slider slides="[{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599417705-BpuWiY-Picture2.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599417705-RNAPbt-Picture3.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599417705-dIljCU-Picture4.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599417705-nRNZwN-Picture5.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599417705-XmugFY-Picture6.png&quot;,&quot;duration&quot;:null}]"></lc-slider><div><div><div class="css-hgmg3m-Container e1l4e1yy0"><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1599417705-BpuWiY-Picture2.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1599417705-RNAPbt-Picture3.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1599417705-dIljCU-Picture4.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1599417705-nRNZwN-Picture5.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1599417705-XmugFY-Picture6.png"></div><div class="css-y1zd58-Container e2y5b7y0"><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y2 css-2gwest-icon-Button-AutoPlayButton"><defs><path id="play-arrow_svg__a" d="M8 5v14l11-7z"></path><mask id="play-arrow_svg__b"><use fill-rule="evenodd" xlink:href="#play-arrow_svg__a"></use></mask></defs><g fill-rule="evenodd"><use xlink:href="#play-arrow_svg__a"></use><g fill-rule="nonzero" mask="url(#play-arrow_svg__b)"><path d="M0 0h24v24H0z"></path></g></g></svg><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y1 css-bs8j34-icon-Button"><path d="M18 18l-8.5-6L18 6zM8 6v12H6V6z"></path></svg><span class="css-iq4chg-Indicator e2y5b7y3">1 / 5</span><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y1 css-bs8j34-icon-Button"><path d="M6 18l8.5-6L6 6zM16 6v12h2V6z"></path></svg></div></div></div></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, head: ListNode, val: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="comment"># 如果头节点的值就是要删除的值，直接返回头节点的下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> head.val == val: <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始化两个指针，pre指向当前节点，cur指向下一个节点</span></span><br><span class="line">        pre, cur = head, head.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历链表，直到找到值为val的节点或者到达链表末尾</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.val != val:</span><br><span class="line">            <span class="comment"># 同时移动pre和cur指针</span></span><br><span class="line">            pre, cur = cur, cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果找到了值为val的节点（cur不为空），删除该节点</span></span><br><span class="line">        <span class="keyword">if</span> cur: pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 返回头节点，因为头节点可能没有变化</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"><span class="comment"># 作者：Krahets</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode.cn/leetbook/read/illustration-of-algorithm/lh2jri/</span></span><br><span class="line"><span class="comment"># 来源：力扣（LeetCode）</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图书整理1</title>
      <link href="/2024/05/04/%E5%9B%BE%E4%B9%A6%E6%95%B4%E7%90%861/"/>
      <url>/2024/05/04/%E5%9B%BE%E4%B9%A6%E6%95%B4%E7%90%861/</url>
      
        <content type="html"><![CDATA[<h1 id="图书整理-I"><a href="#图书整理-I" class="headerlink" title="图书整理 I"></a>图书整理 I</h1><p>书店店员有一张链表形式的书单，每个节点代表一本书，节点中的值表示书的编号。为更方便整理书架，店员需要将书单倒过来排列，就可以从最后一本书开始整理，逐一将书放回到书架上。请倒序返回这个书单链表。</p><hr><p><strong>示例 1：</strong></p><p>输入：head &#x3D; [3,6,4,1]</p><p>输出：[1,4,6,3]</p><p><strong>提示：</strong></p><p>$0 &lt;&#x3D; 链表长度 &lt;&#x3D; 10000$</p><hr><h2 id="初版"><a href="#初版" class="headerlink" title="初版"></a>初版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val  <span class="comment"># 节点存储的值</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span>  <span class="comment"># 指向下一个节点的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBookList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 初始化前一个节点为None</span></span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 初始化当前节点为链表的头节点</span></span><br><span class="line">        current = head</span><br><span class="line">        <span class="comment"># 当当前节点不为None时，进行循环</span></span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="comment"># 保存下一个节点</span></span><br><span class="line">            next_node = current.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 将当前节点的next指针指向前一个节点，实现反转</span></span><br><span class="line">            current.<span class="built_in">next</span> = prev</span><br><span class="line">            <span class="comment"># 更新前一个节点为当前节点</span></span><br><span class="line">            prev = current</span><br><span class="line">            <span class="comment"># 移动当前节点到下一个节点</span></span><br><span class="line">            current = next_node</span><br><span class="line">        <span class="comment"># 当循环结束，当前节点为None，此时前一个节点为反转后链表的头节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 创建一个空列表来存储链表的值</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="comment"># 遍历反转后的链表</span></span><br><span class="line">        <span class="keyword">while</span> prev:</span><br><span class="line">            <span class="comment"># 将当前节点的值添加到结果列表中</span></span><br><span class="line">            result.append(prev.val)</span><br><span class="line">            <span class="comment"># 移动到下一个节点</span></span><br><span class="line">            prev = prev.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 返回结果列表</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><lc-slider slides="[{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599284309-ongbxB-Picture1.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599284309-sNAjgz-Picture2.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599284309-lsJzwg-Picture3.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599284309-WEexSa-Picture4.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599284309-aAAzfv-Picture5.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599284309-AwHMnh-Picture6.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599284309-TPcwUZ-Picture7.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599284309-sBtikj-Picture8.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599284504-Zuewmm-Picture8-1.png&quot;,&quot;duration&quot;:null}]"></lc-slider><div><div><div class="css-hgmg3m-Container e1l4e1yy0"><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1599284309-ongbxB-Picture1.png" hidden=""><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1599284309-sNAjgz-Picture2.png" hidden=""><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1599284309-lsJzwg-Picture3.png" hidden=""><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1599284309-WEexSa-Picture4.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1599284309-aAAzfv-Picture5.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1599284309-AwHMnh-Picture6.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1599284309-TPcwUZ-Picture7.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1599284309-sBtikj-Picture8.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1599284504-Zuewmm-Picture8-1.png"></div><div class="css-y1zd58-Container e2y5b7y0"><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y2 css-2gwest-icon-Button-AutoPlayButton"><defs><path id="play-arrow_svg__a" d="M8 5v14l11-7z"></path><mask id="play-arrow_svg__b"><use fill-rule="evenodd" xlink:href="#play-arrow_svg__a"></use></mask></defs><g fill-rule="evenodd"><use xlink:href="#play-arrow_svg__a"></use><g fill-rule="nonzero" mask="url(#play-arrow_svg__b)"><path d="M0 0h24v24H0z"></path></g></g></svg><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y1 css-bs8j34-icon-Button"><path d="M18 18l-8.5-6L18 6zM8 6v12H6V6z"></path></svg><span class="css-iq4chg-Indicator e2y5b7y3">4 / 9</span><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y1 css-bs8j34-icon-Button"><path d="M6 18l8.5-6L6 6zM16 6v12h2V6z"></path></svg></div></div></div></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val  <span class="comment"># 节点存储的值</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span>  <span class="comment"># 指向下一个节点的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBookList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 如果头节点不为空，递归地反转后续链表，并将当前节点的值添加到反转后的列表末尾</span></span><br><span class="line">        <span class="comment"># 如果头节点为空，返回一个空列表</span></span><br><span class="line">        <span class="keyword">return</span> self.reverseBookList(head.<span class="built_in">next</span>) + [head.val] <span class="keyword">if</span> head <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure><h2 id="辅助栈"><a href="#辅助栈" class="headerlink" title="辅助栈"></a>辅助栈</h2><p><lc-slider slides="[{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599284309-uVDdUn-Picture9.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599284309-bkTHcM-Picture10.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599284309-pjcVQL-Picture11.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599284309-CdJEZQ-Picture12.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599284309-hpDDSU-Picture13.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599284309-BTfQdQ-Picture14.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599284309-RplwUC-Picture15.png&quot;,&quot;duration&quot;:null},{&quot;url&quot;:&quot;https://pic.leetcode-cn.com/1599284309-JIonvw-Picture16.png&quot;,&quot;duration&quot;:null}]"></lc-slider><div><div><div class="css-hgmg3m-Container e1l4e1yy0"><img class="no-preview css-58ju5r-Img e1l4e1yy1" src="https://pic.leetcode-cn.com/1599284309-uVDdUn-Picture9.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1599284309-bkTHcM-Picture10.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1599284309-pjcVQL-Picture11.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1599284309-CdJEZQ-Picture12.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1599284309-hpDDSU-Picture13.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1599284309-BTfQdQ-Picture14.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1599284309-RplwUC-Picture15.png"><img class="no-preview css-58ju5r-Img e1l4e1yy1" hidden="" src="https://pic.leetcode-cn.com/1599284309-JIonvw-Picture16.png"></div><div class="css-y1zd58-Container e2y5b7y0"><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y2 css-2gwest-icon-Button-AutoPlayButton"><defs><path id="play-arrow_svg__a" d="M8 5v14l11-7z"></path><mask id="play-arrow_svg__b"><use fill-rule="evenodd" xlink:href="#play-arrow_svg__a"></use></mask></defs><g fill-rule="evenodd"><use xlink:href="#play-arrow_svg__a"></use><g fill-rule="nonzero" mask="url(#play-arrow_svg__b)"><path d="M0 0h24v24H0z"></path></g></g></svg><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y1 css-bs8j34-icon-Button"><path d="M18 18l-8.5-6L18 6zM8 6v12H6V6z"></path></svg><span class="css-iq4chg-Indicator e2y5b7y3">1 / 8</span><svg viewBox="0 0 24 24" width="1em" height="1em" class="e2y5b7y1 css-bs8j34-icon-Button"><path d="M6 18l8.5-6L6 6zM16 6v12h2V6z"></path></svg></div></div></div></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val  <span class="comment"># 节点存储的值</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span>  <span class="comment"># 指向下一个节点的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBookList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []  <span class="comment"># 创建一个空列表来存储链表的值</span></span><br><span class="line">        <span class="keyword">while</span> head:  <span class="comment"># 当头节点不为空时，进入循环</span></span><br><span class="line">            res.append(head.val)  <span class="comment"># 将当前节点的值添加到结果列表中</span></span><br><span class="line">            head = head.<span class="built_in">next</span>  <span class="comment"># 移动头节点到下一个节点</span></span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]  <span class="comment"># 返回结果列表的逆序，即反转链表的值列表</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动零</title>
      <link href="/2024/05/04/%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
      <url>/2024/05/04/%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h1><p>给定一个数组<code>nums</code>，编写一个函数将所有<code>0</code>移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><hr><p><strong>示例 1:</strong></p><p>输入: nums &#x3D; [0,1,0,3,12]<br>输出: [1,3,12,0,0]</p><p><strong>示例 2:</strong></p><p>输入: nums &#x3D; [0]<br>输出: [0]</p><p><strong>提示:</strong></p><p>$1 &lt;&#x3D; nums.length &lt;&#x3D; 104$<br>$-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1$</p><p><strong>进阶：</strong>你能尽量减少完成的操作次数吗？</p><hr><h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 双指针技术</span></span><br><span class="line">        <span class="comment"># next_non_zero 用于跟踪下一个非零元素应该放置的位置</span></span><br><span class="line">        next_non_zero = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历数组，将非零元素移动到数组的开头</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> i != next_non_zero:</span><br><span class="line">                    nums[next_non_zero], nums[i] = nums[i], nums[next_non_zero]</span><br><span class="line">                next_non_zero += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 不需要返回任何值，因为直接修改了输入数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果该文件作为主程序运行</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">12</span>]</span><br><span class="line">    s.moveZeroes(nums)</span><br><span class="line">    <span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure><h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个名为Solution的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 定义一个名为moveZeroes的实例方法，接收一个整数列表作为参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 使用双指针技术</span></span><br><span class="line">        <span class="comment"># next_non_zero指针用于跟踪下一个非零元素应该放置的位置</span></span><br><span class="line">        next_non_zero = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历数组，将非零元素移动到数组的开头</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 如果当前元素不为0</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 如果当前元素的位置不等于next_non_zero指针的位置</span></span><br><span class="line">                <span class="comment"># 即当前元素不是已经在正确的位置上的非零元素</span></span><br><span class="line">                <span class="keyword">if</span> i != next_non_zero:</span><br><span class="line">                    <span class="comment"># 将当前非零元素移动到next_non_zero指针的位置</span></span><br><span class="line">                    nums[next_non_zero] = nums[i]</span><br><span class="line">                <span class="comment"># next_non_zero指针向后移动一位，指向下一个应该放置非零元素的位置</span></span><br><span class="line">                next_non_zero += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 填充剩余的位置为零</span></span><br><span class="line">        <span class="comment"># 从next_non_zero指针到数组末尾的元素都应该被置为0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(next_non_zero, <span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 不需要返回任何值，因为直接修改了输入数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果该文件作为主程序运行</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建一个Solution类的实例</span></span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="comment"># 定义一个包含零的列表</span></span><br><span class="line">    nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">12</span>]</span><br><span class="line">    <span class="comment"># 调用实例方法moveZeroes，传入列表</span></span><br><span class="line">    s.moveZeroes(nums)</span><br><span class="line">    <span class="comment"># 打印修改后的列表</span></span><br><span class="line">    <span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除排序数组中的重复项</title>
      <link href="/2024/05/04/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>/2024/05/04/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h1><p>给你一个 非严格递增排列 的数组<code>nums</code>，请你<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的<code>相对顺序</code>应该保持 一致 。然后返回<code>nums</code>中唯一元素的个数。</p><p>考虑<code>nums</code>的唯一元素的数量为<code>k</code>，你需要做以下事情确保你的题解可以被通过：</p><p>更改数组<code>nums</code>，使 nums 的前<code>k</code>个元素包含唯一元素，并按照它们最初在<code>nums</code>中出现的顺序排列<code>nums</code>的其余元素与<code>nums</code>的大小不重要。<br>返回<code>k </code>。</p><p><strong>判题标准:</strong></p><p>系统会用下面的代码来测试你的题解:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = [...]; <span class="comment">// 输入数组</span></span><br><span class="line"><span class="type">int</span>[] expectedNums = [...]; <span class="comment">// 长度正确的期望答案</span></span><br><span class="line"><span class="type">int</span> k = <span class="built_in">removeDuplicates</span>(nums); <span class="comment">// 调用</span></span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有断言都通过，那么您的题解将被通过。</p><hr><p><strong>示例 1：</strong></p><p>输入：nums &#x3D; [1,1,2]<br>输出：2, nums &#x3D; [1,2,_]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</p><p><strong>示例 2：</strong></p><p>输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums &#x3D; [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</p><p><strong>提示：</strong></p><p>$1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104$<br>$-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104$<br>$nums$已按<strong>非严格递增</strong>排列</p><hr><h2 id="so-easy"><a href="#so-easy" class="headerlink" title="so easy"></a>so easy</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个Solution类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化一个指针i，用来指向下一个非重复元素应该放置的位置</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 获取数组的长度</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历数组中的每个元素</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 如果当前元素与i指向的元素相同，说明是重复元素</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[j]:</span><br><span class="line">                <span class="comment"># 继续遍历下一个元素</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果当前元素与i指向的元素不同，说明遇到了一个新的非重复元素</span></span><br><span class="line">                <span class="comment"># 将这个新的非重复元素放置在i的下一个位置</span></span><br><span class="line">                nums[i+<span class="number">1</span>] = nums[j]</span><br><span class="line">                <span class="comment"># 将i向前移动一位，指向下一个非重复元素应该放置的位置</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 函数返回的是非重复元素的个数，即i+1</span></span><br><span class="line">        <span class="comment"># 因为i是从0开始计数的，所以非重复元素的个数是i+1</span></span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果这个文件是作为主程序运行，而不是被导入到其他模块中</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建一个Solution类的实例</span></span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="comment"># 调用removeDuplicates方法，并打印结果</span></span><br><span class="line">    <span class="built_in">print</span>(s.removeDuplicates([<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>]))</span><br><span class="line">    <span class="comment"># 输出应该是去重后的数组长度，即6，数组变为[0,1,2,3,4,_,_,_,_,_]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++循环结构</title>
      <link href="/2024/05/03/c-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/"/>
      <url>/2024/05/03/c-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求整数的和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr; <span class="comment">// 创建一个整数类型的vector，用于存储输入的整数</span></span><br><span class="line">    <span class="type">int</span> input; <span class="comment">// 用于存储用户输入的整数</span></span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>; <span class="comment">// 用于存储最大值，初始化为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无限循环，直到用户输入0</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; input; <span class="comment">// 从用户那里读取一个整数</span></span><br><span class="line">        <span class="keyword">if</span> (input == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 如果用户输入了0，则退出循环</span></span><br><span class="line">        arr.<span class="built_in">push_back</span>(input); <span class="comment">// 将用户输入的整数添加到vector的末尾</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历vector中的所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素大于目前记录的最大值</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            max = arr[i]; <span class="comment">// 更新最大值为当前元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出找到的最大值</span></span><br><span class="line">    cout &lt;&lt; max &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 程序正常结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; <span class="comment">// 用于存储用户输入的整数</span></span><br><span class="line">    <span class="type">int</span> count1 = <span class="number">0</span>; <span class="comment">// 用于统计正数的数量</span></span><br><span class="line">    <span class="type">int</span> sum1 = <span class="number">0</span>; <span class="comment">// 用于计算正数的总和</span></span><br><span class="line">    <span class="type">int</span> count2 = <span class="number">0</span>; <span class="comment">// 用于统计负数的数量</span></span><br><span class="line">    <span class="type">int</span> sum2 = <span class="number">0</span>; <span class="comment">// 用于计算负数的总和</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从用户那里读取一个整数</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当用户输入的整数不为0时，继续循环</span></span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果输入的整数大于0，则增加正数的数量和总和</span></span><br><span class="line">            count1++;</span><br><span class="line">            sum1 += n;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果输入的整数小于0，则增加负数的数量和总和</span></span><br><span class="line">            count2++;</span><br><span class="line">            sum2 += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 继续从用户那里读取下一个整数</span></span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出正数的数量、总和、负数的数量和总和</span></span><br><span class="line">    cout &lt;&lt; count1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; sum1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; count2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; sum2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 程序正常结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k; <span class="comment">// 用于存储用户想要生成的斐波那契数列的项数</span></span><br><span class="line">    cin &gt;&gt; k; <span class="comment">// 从用户那里读取斐波那契数列的项数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>; <span class="comment">// 初始化第一个斐波那契数</span></span><br><span class="line">    <span class="type">int</span> b = <span class="number">1</span>; <span class="comment">// 初始化第二个斐波那契数</span></span><br><span class="line">    <span class="type">int</span> c = <span class="number">1</span>; <span class="comment">// 用于存储下一个斐波那契数</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 用于迭代计数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当迭代次数小于用户指定的项数减去2时，继续循环</span></span><br><span class="line">    <span class="comment">// 因为斐波那契数列的前两个数是已知的（1, 1），所以从第三个数开始计算</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; k - <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = a + b; <span class="comment">// 计算下一个斐波那契数</span></span><br><span class="line">        a = b; <span class="comment">// 更新第一个斐波那契数为当前的第二个斐波那契数</span></span><br><span class="line">        b = c; <span class="comment">// 更新第二个斐波那契数为刚刚计算出的下一个斐波那契数</span></span><br><span class="line">        i++; <span class="comment">// 增加迭代次数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出第k个斐波那契数</span></span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 程序正常结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n; <span class="comment">// 用于存储用户输入的三角形高度</span></span><br><span class="line">    cin &gt;&gt; n; <span class="comment">// 从用户那里读取三角形的高度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外循环控制行数，从0到n-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 内循环控制每行打印的星号数量，从0到i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++) <span class="comment">// 注意这里应该是 j &lt;= i</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;*&#x27;</span>; <span class="comment">// 打印一个星号</span></span><br><span class="line">        cout &lt;&lt; endl; <span class="comment">// 在每行星号打印完成后换行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 程序正常结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 水仙花数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">100</span>; i &lt;= <span class="number">999</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">m = i / <span class="number">100</span>;</span><br><span class="line">n = (i - m * <span class="number">100</span>) / <span class="number">10</span>;</span><br><span class="line">k = i - m * <span class="number">100</span> - n * <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">pow</span>(m, <span class="number">3</span>) + <span class="built_in">pow</span>(n, <span class="number">3</span>) + <span class="built_in">pow</span>(k,<span class="number">3</span>) == i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个判断素数的函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果a小于2，不是素数</span></span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 循环从2开始，到sqrt(a)结束</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(a); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果a能被i整除，则a不是素数</span></span><br><span class="line">            <span class="keyword">if</span> (a % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有找到能整除a的数，则a是素数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b; <span class="comment">// 定义两个整型变量a和b</span></span><br><span class="line">    std::cin &gt;&gt; a &gt;&gt; b; <span class="comment">// 从用户输入中读取两个数，分别赋值给a和b</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环从a开始，到b结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a; i &lt;= b; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果当前数i是素数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_prime</span>(i))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 输出这个素数</span></span><br><span class="line">            std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main函数返回0，表示程序正常结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个计算阶乘的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果i小于等于1，阶乘为1</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 否则，阶乘为i乘以i-1的阶乘</span></span><br><span class="line">        <span class="keyword">return</span> i * <span class="built_in">factorial</span>(i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> e = <span class="number">1.0</span>; <span class="comment">// 初始化e为1.0，以保持高精度</span></span><br><span class="line">    <span class="type">int</span> n; <span class="comment">// 定义变量n，用于存储用户输入的迭代次数</span></span><br><span class="line">    std::cin &gt;&gt; n; <span class="comment">// 从用户输入中读取迭代次数，赋值给n</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环从1开始，到n结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将1.0除以i的阶乘，然后累加到e上，以计算e的近似值</span></span><br><span class="line">        e += <span class="number">1.0</span> / <span class="built_in">factorial</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出计算得到的e的近似值</span></span><br><span class="line">    std::cout &lt;&lt; e &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// main函数返回0，表示程序正常结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 循环结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杨辉三角形</title>
      <link href="/2024/05/02/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
      <url>/2024/05/02/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h1><p>给定一个非负整数<code>numRows</code>，生成「杨辉三角」的前<code>numRows</code>行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p><img src="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="杨辉三角"></p><hr><p><strong>示例 1:</strong></p><p>输入: numRows &#x3D; 5<br>输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</p><p><strong>示例 2:</strong></p><p>输入: numRows &#x3D; 1<br>输出: [[1]]</p><p><strong>提示:</strong></p><p>$1 &lt;&#x3D; numRows &lt;&#x3D; 30$</p><hr><h2 id="初版"><a href="#初版" class="headerlink" title="初版"></a>初版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个名为Solution的类，用于解决给定问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 定义一个名为generate的方法，接收一个整数参数numRows，返回一个整数列表的列表</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self, numRows: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 初始化一个名为triangle的二维列表，用于表示杨辉三角</span></span><br><span class="line">        <span class="comment"># triangle的每一行都是一个列表，列表的长度等于当前行号加一</span></span><br><span class="line">        <span class="comment"># 列表的每个元素都是1，因为杨辉三角的每一行的两端都是1</span></span><br><span class="line">        triangle = [[<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numRows) <span class="keyword">if</span> i &lt;= j] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(numRows)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历杨辉三角的每一行，从第二行开始，因为第一行已经初始化为[1]</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(numRows):</span><br><span class="line">            <span class="comment"># 遍历当前行的每一列，从第一列开始，到当前行号结束</span></span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(row + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 如果当前列是第一列或最后一列，则当前元素为1</span></span><br><span class="line">                <span class="keyword">if</span> col == <span class="number">0</span> <span class="keyword">or</span> col == row:</span><br><span class="line">                    triangle[row][col] = <span class="number">1</span></span><br><span class="line">                <span class="comment"># 否则，当前元素等于上一行的当前列和上一列的和</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    triangle[row][col] = triangle[row - <span class="number">1</span>][col - <span class="number">1</span>] + triangle[row - <span class="number">1</span>][col]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 返回杨辉三角</span></span><br><span class="line">        <span class="keyword">return</span> triangle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果当前文件是主程序，则执行以下代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建一个Solution类的实例</span></span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="comment"># 调用实例的generate方法，生成一个10行的杨辉三角，并打印结果</span></span><br><span class="line">    <span class="built_in">print</span>(s.generate(<span class="number">10</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个名为Solution的类，用于解决给定问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 定义一个名为generate的方法，接收一个整数参数numRows，返回一个整数列表的列表</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self, numRows: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 初始化一个空列表来存储杨辉三角</span></span><br><span class="line">        triangle = []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历从0到numRows-1的范围，代表杨辉三角的每一行</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(numRows):</span><br><span class="line">            <span class="comment"># 如果是第一行，直接添加[1]作为杨辉三角的第一行</span></span><br><span class="line">            <span class="keyword">if</span> row == <span class="number">0</span>:</span><br><span class="line">                triangle.append([<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 新的一行是基于上一行的，初始化为上一行的长度加1，所有元素都是1</span></span><br><span class="line">                <span class="comment"># 因为杨辉三角的每一行两端的元素都是1</span></span><br><span class="line">                new_row = [<span class="number">1</span>] * (row + <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 更新新行中的内部元素（除了两端的1）</span></span><br><span class="line">                <span class="comment"># 从第二列开始，到倒数第二列结束</span></span><br><span class="line">                <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, row):</span><br><span class="line">                    <span class="comment"># 杨辉三角的每个元素（除了两端的1）是它上方和左上方两个元素之和</span></span><br><span class="line">                    new_row[col] = triangle[row - <span class="number">1</span>][col - <span class="number">1</span>] + triangle[row - <span class="number">1</span>][col]</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 将新行添加到杨辉三角中</span></span><br><span class="line">                triangle.append(new_row)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 返回生成的杨辉三角</span></span><br><span class="line">        <span class="keyword">return</span> triangle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果当前文件是主程序，则执行以下代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建一个Solution类的实例</span></span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="comment"># 调用实例的generate方法，生成一个10行的杨辉三角，并打印结果</span></span><br><span class="line">    <span class="built_in">print</span>(s.generate(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长度最小的子数组</title>
      <link href="/2024/05/02/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2024/05/02/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h1><p>给定一个含有<code>n</code>个正整数的数组和一个正整数<code>target</code>。</p><p>找出该数组中满足其总和大于等于<code>target</code>的长度最小的 连续子数组<code>[numsl, numsl+1, ..., numsr-1, numsr]</code>，并返回其长度。如果不存在符合条件的子数组，返回<code>0</code>。</p><hr><p><strong>示例 1：</strong></p><p>输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p><p><strong>示例 2：</strong></p><p>输入：target &#x3D; 4, nums &#x3D; [1,4,4]<br>输出：1</p><p><strong>示例 3：</strong></p><p>输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]<br>输出：0</p><p><strong>提示：</strong></p><ul><li>$1 &lt;&#x3D; target &lt;&#x3D; 109$</li><li>$1 &lt;&#x3D; nums.length &lt;&#x3D; 105$</li><li>$1 &lt;&#x3D; nums[i] &lt;&#x3D; 105$</li></ul><p><strong>进阶：</strong></p><ul><li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li></ul><hr><h2 id="初版"><a href="#初版" class="headerlink" title="初版"></a>初版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化一个列表来存储所有满足条件的子数组长度</span></span><br><span class="line">        len_lis = []</span><br><span class="line">        <span class="comment"># 初始化一个变量来存储当前的和</span></span><br><span class="line">        sum_ = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 初始化一个变量来作为滑动窗口的起始索引</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历数组，使用j作为滑动窗口的结束索引</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 将当前元素加到sum_中</span></span><br><span class="line">            sum_ += nums[j]</span><br><span class="line">            <span class="comment"># 当sum_大于或等于target时，开始缩小窗口</span></span><br><span class="line">            <span class="keyword">while</span> sum_ &gt;= target:</span><br><span class="line">                <span class="comment"># 将当前窗口的长度（j - i + 1）添加到len_lis中</span></span><br><span class="line">                len_lis.append(j - i + <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 减去窗口起始元素的值，准备移动窗口起始索引</span></span><br><span class="line">                sum_ -= nums[i]</span><br><span class="line">                <span class="comment"># 窗口起始索引右移</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果len_lis不为空，返回其中最小的值</span></span><br><span class="line">        <span class="keyword">if</span> len_lis:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(len_lis)</span><br><span class="line">        <span class="comment"># 如果len_lis为空，说明没有找到满足条件的子数组，返回0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="built_in">print</span>(s.minSubArrayLen(<span class="number">4</span>, [<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>]))</span><br></pre></td></tr></table></figure><h2 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化窗口的和以及最小长度</span></span><br><span class="line">        window_sum = <span class="number">0</span></span><br><span class="line">        min_length = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始化窗口的起始位置</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历数组，使用end作为窗口的结束位置</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 将当前元素添加到窗口的和</span></span><br><span class="line">            window_sum += nums[end]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当窗口的和大于等于目标值时</span></span><br><span class="line">            <span class="keyword">while</span> window_sum &gt;= target:</span><br><span class="line">                <span class="comment"># 更新最小长度</span></span><br><span class="line">                min_length = <span class="built_in">min</span>(min_length, end - start + <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 移除窗口的起始元素，并移动窗口的起始位置</span></span><br><span class="line">                window_sum -= nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果最小长度没有被更新过，说明没有找到满足条件的子数组</span></span><br><span class="line">        <span class="keyword">if</span> min_length == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 返回最小长度</span></span><br><span class="line">        <span class="keyword">return</span> min_length</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Solution对象</span></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="comment"># 测试函数</span></span><br><span class="line"><span class="built_in">print</span>(s.minSubArrayLen(<span class="number">4</span>, [<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>]))  <span class="comment"># 输出应为2，因为[4,4]是满足条件的最短子数组</span></span><br></pre></td></tr></table></figure><h2 id="前缀和-二分搜索"><a href="#前缀和-二分搜索" class="headerlink" title="前缀和+二分搜索"></a>前缀和+二分搜索</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 计算前缀和</span></span><br><span class="line">        prefix_sum = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            prefix_sum.append(prefix_sum[-<span class="number">1</span>] + num)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始化最小长度为无穷大</span></span><br><span class="line">        min_length = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历前缀和数组，使用二分搜索找到最短的子数组</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prefix_sum)):</span><br><span class="line">            <span class="comment"># 我们需要找到最小的 j，使得 prefix_sum[j] - prefix_sum[i-1] &gt;= target</span></span><br><span class="line">            <span class="comment"># 这等价于找到最小的 j，使得 prefix_sum[j] &gt;= prefix_sum[i-1] + target</span></span><br><span class="line">            target_sum = prefix_sum[i-<span class="number">1</span>] + target</span><br><span class="line">            j = bisect.bisect_left(prefix_sum, target_sum)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果找到了满足条件的最小的 j</span></span><br><span class="line">            <span class="keyword">if</span> j != <span class="built_in">len</span>(prefix_sum):</span><br><span class="line">                min_length = <span class="built_in">min</span>(min_length, j - i + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果最小长度没有被更新过，说明没有找到满足条件的子数组</span></span><br><span class="line">        <span class="keyword">if</span> min_length == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 返回最小长度</span></span><br><span class="line">        <span class="keyword">return</span> min_length</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Solution对象</span></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="comment"># 测试函数</span></span><br><span class="line"><span class="built_in">print</span>(s.minSubArrayLen(<span class="number">4</span>, [<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>]))  <span class="comment"># 输出应为2，因为[4,4]是满足条件的最短子数组</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 滑动窗口法 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 二分搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两数之和</title>
      <link href="/2024/05/02/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2024/05/02/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="两数之和-II-输入有序数组"><a href="#两数之和-II-输入有序数组" class="headerlink" title="两数之和 II - 输入有序数组"></a>两数之和 II - 输入有序数组</h1><p>给你一个下标从 1 开始的整数数组 <code>numbers</code> ，该数组已按<strong>非递减顺序排列</strong>，请你从数组中找出满足相加之和等于目标数 <code>target</code>的两个数。如果设这两个数分别是 <code>numbers[index1]</code> 和 <code>numbers[index2]</code>，则 <code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code> 。</p><p>以长度为 2 的整数数组 <code>[index1, index2]</code>的形式返回这两个整数的下标 <code>index1</code> 和<code> index2</code>。</p><p>你可以假设每个输入<strong>只对应唯一的答案</strong>，而且你<strong>不可以</strong>重复使用相同的元素。</p><p>你所设计的解决方案必须只使用常量级的额外空间。</p><hr><p><strong>示例 1：</strong></p><p>输入：numbers &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[1,2]<br>解释：2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。返回 [1, 2] 。</p><p><strong>示例 2：</strong></p><p>输入：numbers &#x3D; [2,3,4], target &#x3D; 6<br>输出：[1,3]<br>解释：2 与 4 之和等于目标数 6 。因此 index1 &#x3D; 1, index2 &#x3D; 3 。返回 [1, 3] 。</p><p><strong>示例 3：</strong></p><p>输入：numbers &#x3D; [-1,0], target &#x3D; -1<br>输出：[1,2]<br>解释：-1 与 0 之和等于目标数 -1 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。返回 [1, 2] 。</p><p><strong>提示：</strong></p><p>$2 &lt;&#x3D; numbers.length &lt;&#x3D; 3 * 104$<br>$-1000 &lt;&#x3D; numbers[i] &lt;&#x3D; 1000$<br>$numbers $按<strong>非递减顺序</strong>排列<br>$-1000 &lt;&#x3D; target &lt;&#x3D; 1000$<br>仅存在一个有效答案</p><hr><h2 id="最优解"><a href="#最优解" class="headerlink" title="最优解"></a>最优解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">numbers, target</span>):</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(numbers) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="built_in">sum</span> = numbers[left] + numbers[right]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span> == target:</span><br><span class="line">            <span class="keyword">return</span> [left + <span class="number">1</span>, right + <span class="number">1</span>]  <span class="comment"># 题目要求下标从 1 开始</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">sum</span> &lt; target:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> []  <span class="comment"># 如果没有找到满足条件的两个数，则返回空数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">numbers = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>]</span><br><span class="line">target = <span class="number">9</span></span><br><span class="line"><span class="built_in">print</span>(twoSum(numbers, target))  <span class="comment"># 输出应该是 [1, 2]，因为 numbers[1] + numbers[2] = 9</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现KMP算法</title>
      <link href="/2024/05/02/%E5%AE%9E%E7%8E%B0KMP%E7%AE%97%E6%B3%95/"/>
      <url>/2024/05/02/%E5%AE%9E%E7%8E%B0KMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="实现-strStr"><a href="#实现-strStr" class="headerlink" title="实现 strStr()"></a>实现 strStr()</h1><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</p><hr><p><strong>示例 1：</strong></p><p>输入：haystack &#x3D; “sadbutsad”, needle &#x3D; “sad”<br>输出：0<br>解释：”sad” 在下标 0 和 6 处匹配。<br>第一个匹配项的下标是 0 ，所以返回 0 。</p><p><strong>示例 2：</strong></p><p>输入：haystack &#x3D; “leetcode”, needle &#x3D; “leeto”<br>输出：-1<br>解释：”leeto” 没有在 “leetcode” 中出现，所以返回 -1 。</p><p><strong>提示：</strong></p><p>$1 &lt;&#x3D; haystack.length, needle.length &lt;&#x3D; 104$<br>$haystack $和$ needle$ 仅由小写英文字符组成</p><hr><h2 id="初版"><a href="#初版" class="headerlink" title="初版"></a>初版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 构建needle字符串的next数组</span></span><br><span class="line">        <span class="built_in">next</span> = self.build_next_array(needle)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># i表示在haystack中当前字符的位置，j表示在needle中当前字符的位置</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历haystack字符串，寻找needle字符串</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(haystack):</span><br><span class="line">            <span class="comment"># 如果当前字符匹配</span></span><br><span class="line">            <span class="keyword">if</span> haystack[i] == needle[j]:</span><br><span class="line">                <span class="comment"># 移动i和j指针</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果needle字符串中的字符不再匹配，并且j大于0，则j移动到前一个位置的前缀长度</span></span><br><span class="line">            <span class="keyword">elif</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                j = <span class="built_in">next</span>[j - <span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 如果needle字符串中的字符不再匹配，并且j为0，则i指针继续移动</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果j等于needle字符串的长度，则找到了needle字符串，返回i-j的值</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="built_in">len</span>(needle):</span><br><span class="line">                <span class="keyword">return</span> i - j</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果needle字符串在haystack中没有找到，则返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_next_array</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        <span class="comment"># 如果字符串s为空，则返回空列表</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化next数组，next数组用于存储每个位置的最长公共前缀长度</span></span><br><span class="line">        <span class="built_in">next</span> = [<span class="number">0</span>] * <span class="built_in">len</span>(s)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># i表示当前字符的位置，j表示前缀的长度</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历字符串s，从第二个字符开始</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="comment"># 如果当前字符与前缀的下一个字符匹配</span></span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                <span class="comment"># 增加前缀长度</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 更新next数组，将当前位置的前缀长度设置为j</span></span><br><span class="line">                <span class="built_in">next</span>[i] = j</span><br><span class="line">                <span class="comment"># 移动i指针到下一个字符</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果不匹配，且j不为0，则j向前移动到前一个位置的前缀长度</span></span><br><span class="line">                <span class="keyword">if</span> j != <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 移动j指针到前一个位置的前缀长度</span></span><br><span class="line">                    j = <span class="built_in">next</span>[j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果j为0，则当前字符的前缀长度为0</span></span><br><span class="line">                    <span class="comment"># 更新next数组，将当前位置的前缀长度设置为0</span></span><br><span class="line">                    <span class="built_in">next</span>[i] = <span class="number">0</span></span><br><span class="line">                    <span class="comment"># 移动i指针到下一个字符</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回构建好的next数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span></span><br></pre></td></tr></table></figure><h2 id="优化版-差别不大"><a href="#优化版-差别不大" class="headerlink" title="优化版(差别不大)"></a>优化版(差别不大)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> needle:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 构建needle字符串的next数组</span></span><br><span class="line">        <span class="built_in">next</span> = self.build_next_array(needle)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># i表示在haystack中当前字符的位置，j表示在needle中当前字符的位置</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历haystack字符串，寻找needle字符串</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(haystack):</span><br><span class="line">            <span class="comment"># 如果当前字符匹配</span></span><br><span class="line">            <span class="keyword">if</span> haystack[i] == needle[j]:</span><br><span class="line">                <span class="comment"># 移动i和j指针</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果needle字符串中的字符不再匹配，并且j大于0，则j移动到前一个位置的前缀长度</span></span><br><span class="line">            <span class="keyword">elif</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                j = <span class="built_in">next</span>[j - <span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 如果needle字符串中的字符不再匹配，并且j为0，则i指针继续移动</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果j等于needle字符串的长度，则找到了needle字符串，返回i-j的值</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="built_in">len</span>(needle):</span><br><span class="line">                <span class="keyword">return</span> i - j</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果needle字符串在haystack中没有找到，则返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_next_array</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始化next数组</span></span><br><span class="line">        <span class="built_in">next</span> = [<span class="number">0</span>] * <span class="built_in">len</span>(s)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># i表示当前字符的位置，j表示前缀的长度</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历字符串s，从第二个字符开始</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="comment"># 如果当前字符与前缀的下一个字符匹配</span></span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                <span class="comment"># 增加前缀长度</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 更新next数组，将当前位置的前缀长度设置为j</span></span><br><span class="line">                <span class="built_in">next</span>[i] = j</span><br><span class="line">                <span class="comment"># 移动i指针到下一个字符</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果不匹配，且j不为0，则j向前移动到前一个位置的前缀长度</span></span><br><span class="line">                <span class="keyword">if</span> j != <span class="number">0</span>:</span><br><span class="line">                    j = <span class="built_in">next</span>[j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果j为0，则当前字符的前缀长度为0</span></span><br><span class="line">                    <span class="comment"># 更新next数组，将当前位置的前缀长度设置为0</span></span><br><span class="line">                    <span class="built_in">next</span>[i] = <span class="number">0</span></span><br><span class="line">                    <span class="comment"># 移动i指针到下一个字符</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 返回构建好的next数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> KMP算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>起风了</title>
      <link href="/2024/05/01/%E8%B5%B7%E9%A3%8E%E4%BA%86/"/>
      <url>/2024/05/01/%E8%B5%B7%E9%A3%8E%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1330348068&auto=1&height=66"></iframe><p>这一路上走走停停</p><p>顺着少年漂流的痕迹</p><p>迈出车站的前一刻</p><p>竟有些犹豫</p><p>不禁笑这近乡情怯</p><p>仍无可避免</p><p>而长野的天</p><p>依旧那么暖</p><p>风吹起了从前</p><p>从前初识这世间</p><p>万般流连</p><p>看着天边似在眼前</p><p>也甘愿赴汤蹈火去走它一遍</p><p>如今走过这世间</p><p>万般流连</p><p>翻过岁月不同侧脸</p><p>措不及防闯入你的笑颜</p><p>我曾难自拔于世界之大</p><p>也沉溺于其中梦话</p><p>不得真假 不做挣扎 不惧笑话</p><p>我曾将青春翻涌成她</p><p>也曾指尖弹出盛夏</p><p>心之所动 且就随缘去吧</p><p>逆着光行走 任风吹雨打</p><p>短短的路走走停停</p><p>也有了几分的距离</p><p>不知抚摸的是故事 还是段心情</p><p>也许期待的不过是 与时间为敌</p><p>再次看到你</p><p>微凉晨光里</p><p>笑得很甜蜜</p><p>从前初识这世间</p><p>万般流连</p><p>看着天边似在眼前</p><p>也甘愿赴汤蹈火去走它一遍</p><p>如今走过这世间</p><p>万般流连</p><p>翻过岁月不同侧脸</p><p>措不及防闯入你的笑颜</p><p>我曾难自拔于世界之大</p><p>也沉溺于其中梦话</p><p>不得真假 不做挣扎 不惧笑话</p><p>我曾将青春翻涌成她</p><p>也曾指尖弹出盛夏</p><p>心之所动 且就随缘去吧</p><p>晚风吹起你鬓间的白发</p><p>抚平回忆留下的疤</p><p>你的眼中 明暗交杂 一笑生花</p><p>暮色遮住你蹒跚的步伐</p><p>走进床头藏起的画</p><p>画中的你 低着头说话</p><p>我仍感叹于世界之大</p><p>也沉醉于儿时情话</p><p>不剩真假 不做挣扎 无谓笑话</p><p>我终将青春还给了她</p><p>连同指尖弹出的盛夏</p><p>心之所动 就随风去了</p><p>以爱之名 你还愿意吗</p>]]></content>
      
      
      <categories>
          
          <category> 音乐 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最长回文字串</title>
      <link href="/2024/05/01/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2/"/>
      <url>/2024/05/01/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><p>给你一个字符串 s，找到 s 中最长的回文子串。如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><hr><p><strong>示例 1：</strong></p><p>输入：s &#x3D; “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。</p><p><strong>示例 2：</strong></p><p>输入：s &#x3D; “cbbd”<br>输出：”bb”</p><p><strong>提示：</strong></p><p>$1 &lt;&#x3D; s.length &lt;&#x3D; 1000$<br>s 仅由数字和英文字母组成</p><hr><h2 id="初版"><a href="#初版" class="headerlink" title="初版"></a>初版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个名为 Solution 的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 定义一个判断字符串是否为回文的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_palindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 如果字符串反转后与原字符串相等，则为回文</span></span><br><span class="line">        <span class="keyword">if</span> s[::-<span class="number">1</span>] == s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义一个寻找最长回文子串的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 获取字符串长度</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 创建一个集合用于存储所有回文子串</span></span><br><span class="line">        res = <span class="built_in">set</span>()</span><br><span class="line">        <span class="comment"># 如果字符串长度为1，则直接返回该字符串</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="comment"># 双层循环遍历字符串，寻找所有可能的子串</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">                <span class="comment"># 获取当前子串</span></span><br><span class="line">                tmp = s[i:j+<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 如果当前子串是回文，则添加到集合中</span></span><br><span class="line">                <span class="keyword">if</span> self.is_palindrome(tmp):</span><br><span class="line">                    res.add(s[i:j+<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 返回集合中长度最长的回文子串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res, key=<span class="built_in">len</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果当前模块为主模块，则执行以下代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建 Solution 类的实例</span></span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="comment"># 输出 &quot;bb&quot; 的最长回文子串</span></span><br><span class="line">    <span class="built_in">print</span>(s.longestPalindrome(<span class="string">&quot;bb&quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="中心拓展算法"><a href="#中心拓展算法" class="headerlink" title="中心拓展算法"></a>中心拓展算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">expandAroundCenter</span>(<span class="params">self, s, left, right</span>):</span><br><span class="line">        <span class="comment"># 当左侧指针大于等于0，右侧指针小于字符串长度，且两侧字符相同时</span></span><br><span class="line">        <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">            <span class="comment"># 向两侧扩展</span></span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 返回从 left+1 到 right-1 的子串，即当前找到的最长回文子串</span></span><br><span class="line">        <span class="keyword">return</span> s[left + <span class="number">1</span>:right]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 如果字符串为空，返回空字符串</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化最长回文子串为空</span></span><br><span class="line">        longest_palindrome = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 遍历字符串的每个字符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># 以 s[i] 为中心的最长回文子串（奇数长度）</span></span><br><span class="line">            odd_palindrome = self.expandAroundCenter(s, i, i)</span><br><span class="line">            <span class="comment"># 以 s[i] 和 s[i+1] 为中心的最长回文子串（偶数长度）</span></span><br><span class="line">            even_palindrome = self.expandAroundCenter(s, i, i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果奇数长度的回文子串比当前已知的最长回文子串长</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(odd_palindrome) &gt; <span class="built_in">len</span>(longest_palindrome):</span><br><span class="line">                <span class="comment"># 更新最长回文子串</span></span><br><span class="line">                longest_palindrome = odd_palindrome</span><br><span class="line">            <span class="comment"># 如果偶数长度的回文子串比当前已知的最长回文子串长</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(even_palindrome) &gt; <span class="built_in">len</span>(longest_palindrome):</span><br><span class="line">                <span class="comment"># 更新最长回文子串</span></span><br><span class="line">                longest_palindrome = even_palindrome</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回最终找到的最长回文子串</span></span><br><span class="line">        <span class="keyword">return</span> longest_palindrome</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 获取字符串长度</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 如果字符串为空或只有一个字符，直接返回原字符串</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化最长回文子串的起始和结束索引</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        max_length = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建一个二维数组 dp，用于存储子问题的解</span></span><br><span class="line">        <span class="comment"># dp[i][j] 表示字符串 s[i...j] 是否是回文串</span></span><br><span class="line">        dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 所有长度为 1 的子串都是回文串</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dp[i][i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 动态规划填表</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(end):</span><br><span class="line">                <span class="comment"># 如果头尾字符不同，则不是回文串</span></span><br><span class="line">                <span class="keyword">if</span> s[start] != s[end]:</span><br><span class="line">                    dp[start][end] = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果子串长度小于等于 3，则直接判断为回文串</span></span><br><span class="line">                    <span class="keyword">if</span> end - start &lt;= <span class="number">2</span>:</span><br><span class="line">                        dp[start][end] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># 如果去掉头尾字符后的子串也是回文串，则当前子串也是回文串</span></span><br><span class="line">                        dp[start][end] = dp[start + <span class="number">1</span>][end - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果当前子串是回文串且长度大于已知的最长长度，更新最长长度和起始索引</span></span><br><span class="line">                <span class="keyword">if</span> dp[start][end] <span class="keyword">and</span> end - start + <span class="number">1</span> &gt; max_length:</span><br><span class="line">                    max_length = end - start + <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 更新最长回文子串的起始索引</span></span><br><span class="line">                    start = start</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回最长回文子串</span></span><br><span class="line">        <span class="comment"># 使用切片语法返回从 start 开始，长度为 max_length 的子串</span></span><br><span class="line">        <span class="keyword">return</span> s[start:start + max_length]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果当前模块为主模块，则执行以下代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建 Solution 类的实例</span></span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="comment"># 输出 &quot;bb&quot; 的最长回文子串</span></span><br><span class="line">    <span class="built_in">print</span>(s.longestPalindrome(<span class="string">&quot;bb&quot;</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 中心拓展算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长公共前缀</title>
      <link href="/2024/04/30/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
      <url>/2024/04/30/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
      
        <content type="html"><![CDATA[<h1 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。</p><hr><p><strong>示例 1：</strong></p><p>输入：strs &#x3D; [“flower”,”flow”,”flight”]<br>输出：”fl”</p><p><strong>示例 2：</strong></p><p>输入：strs &#x3D; [“dog”,”racecar”,”car”]<br>输出：””<br>解释：输入不存在公共前缀。</p><p><strong>提示：</strong></p><p>$1 &lt;&#x3D; strs.length &lt;&#x3D; 200$<br>$0 &lt;&#x3D; strs[i].length &lt;&#x3D; 200$<br>$strs[i]$ 仅由小写英文字母组成</p><hr><h2 id="初版"><a href="#初版" class="headerlink" title="初版"></a>初版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个Solution类来包含最长公共前缀的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 首先找到列表中最短的字符串</span></span><br><span class="line">        shortest_str = <span class="built_in">min</span>(strs, key=<span class="built_in">len</span>)</span><br><span class="line">        <span class="comment"># 如果字符串列表中有多个字符串，我们需要进一步比较</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(strs) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 从列表中移除最短的字符串，以便进行比较</span></span><br><span class="line">            strs.remove(shortest_str)</span><br><span class="line">            <span class="comment"># 遍历最短字符串的每个字符</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(shortest_str)):</span><br><span class="line">                <span class="comment"># 使用all函数检查列表中剩余的字符串的当前字符是否都与最短字符串的当前字符相同</span></span><br><span class="line">                <span class="comment"># 如果有一个字符不匹配，返回最短字符串的前i个字符</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">all</span>(s[i] == shortest_str[i] <span class="keyword">for</span> s <span class="keyword">in</span> strs):</span><br><span class="line">                    <span class="keyword">return</span> shortest_str[:i]</span><br><span class="line">            <span class="comment"># 如果所有字符都匹配，返回整个最短字符串</span></span><br><span class="line">            <span class="keyword">return</span> shortest_str</span><br><span class="line">        <span class="comment"># 如果字符串列表中只有一个字符串，直接返回这个字符串</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> shortest_str</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序入口</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建Solution类的实例</span></span><br><span class="line">    solution = Solution()</span><br><span class="line">    <span class="comment"># 调用longestCommonPrefix方法并传入一个示例字符串列表</span></span><br><span class="line">    <span class="built_in">print</span>(solution.longestCommonPrefix([<span class="string">&quot;flower&quot;</span>, <span class="string">&quot;flow&quot;</span>, <span class="string">&quot;flight&quot;</span>]))</span><br></pre></td></tr></table></figure><h2 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 如果字符串列表为空或者不包含任何字符串，返回空字符串</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs <span class="keyword">or</span> <span class="keyword">not</span> strs[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用min函数找到最短的字符串</span></span><br><span class="line">        shortest_str = <span class="built_in">min</span>(strs, key=<span class="built_in">len</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历最短字符串的每个字符</span></span><br><span class="line">        <span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(shortest_str):</span><br><span class="line">            <span class="comment"># 使用all函数检查列表中剩余的字符串的当前字符是否都与最短字符串的当前字符相同</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">all</span>(s[i] == char <span class="keyword">for</span> s <span class="keyword">in</span> strs):</span><br><span class="line">                <span class="keyword">return</span> shortest_str[:i]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果没有公共前缀，返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> shortest_str</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序入口</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建Solution类的实例</span></span><br><span class="line">    solution = Solution()</span><br><span class="line">    <span class="comment"># 调用longestCommonPrefix方法并传入一个示例字符串列表</span></span><br><span class="line">    <span class="built_in">print</span>(solution.longestCommonPrefix([<span class="string">&quot;flower&quot;</span>, <span class="string">&quot;flow&quot;</span>, <span class="string">&quot;flight&quot;</span>]))</span><br></pre></td></tr></table></figure><h2 id="高级解法（分治法）"><a href="#高级解法（分治法）" class="headerlink" title="高级解法（分治法）"></a>高级解法（分治法）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个Solution类来包含最长公共前缀的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义最长公共前缀函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 如果字符串数组为空，返回空字符串</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 使用分治法找到最长公共前缀</span></span><br><span class="line">        <span class="keyword">return</span> self.divide_conquer(strs, <span class="number">0</span>, <span class="built_in">len</span>(strs) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义分治函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">divide_conquer</span>(<span class="params">self, strs, start, end</span>):</span><br><span class="line">        <span class="comment"># 如果开始索引等于结束索引，说明数组中只有一个字符串，直接返回该字符串</span></span><br><span class="line">        <span class="keyword">if</span> start == end:</span><br><span class="line">            <span class="keyword">return</span> strs[start]</span><br><span class="line">        <span class="comment"># 找到中间索引，将数组分成两部分</span></span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="comment"># 递归地找到左半部分的最长公共前缀</span></span><br><span class="line">        left_prefix = self.divide_conquer(strs, start, mid)</span><br><span class="line">        <span class="comment"># 递归地找到右半部分的最长公共前缀</span></span><br><span class="line">        right_prefix = self.divide_conquer(strs, mid + <span class="number">1</span>, end)</span><br><span class="line">        <span class="comment"># 合并左右两边的最长公共前缀</span></span><br><span class="line">        <span class="keyword">return</span> self.common_prefix(left_prefix, right_prefix)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义公共前缀函数，用于合并两个子问题的解</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">common_prefix</span>(<span class="params">self, left, right</span>):</span><br><span class="line">        <span class="comment"># 找到两个字符串长度的最小值</span></span><br><span class="line">        min_len = <span class="built_in">min</span>(<span class="built_in">len</span>(left), <span class="built_in">len</span>(right))</span><br><span class="line">        <span class="comment"># 遍历两个字符串，直到找到不匹配的字符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(min_len):</span><br><span class="line">            <span class="keyword">if</span> left[i] != right[i]:</span><br><span class="line">                <span class="comment"># 返回从开始到不匹配位置的前缀</span></span><br><span class="line">                <span class="keyword">return</span> left[:i]</span><br><span class="line">        <span class="comment"># 如果所有字符都匹配，返回较短的前缀</span></span><br><span class="line">        <span class="keyword">return</span> left[:min_len]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序入口</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建Solution类的实例</span></span><br><span class="line">    solution = Solution()</span><br><span class="line">    <span class="comment"># 调用longestCommonPrefix方法并传入一个示例字符串列表</span></span><br><span class="line">    <span class="built_in">print</span>(solution.longestCommonPrefix([<span class="string">&quot;flower&quot;</span>, <span class="string">&quot;flow&quot;</span>, <span class="string">&quot;flight&quot;</span>]))</span><br></pre></td></tr></table></figure><h2 id="巧解（利用zip方法的特性）"><a href="#巧解（利用zip方法的特性）" class="headerlink" title="巧解（利用zip方法的特性）"></a>巧解（利用zip方法的特性）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        ret = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="comment">#使用zip</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(*strs):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(i)) == <span class="number">1</span>:</span><br><span class="line">                ret += i[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 分治法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对角线遍历</title>
      <link href="/2024/04/30/%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86/"/>
      <url>/2024/04/30/%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="对角线遍历"><a href="#对角线遍历" class="headerlink" title="对角线遍历"></a>对角线遍历</h1><p>给你一个大小为 $m * n $的矩阵 mat ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。</p><hr><p> </p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg"></p><p>输入：mat &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</p><p>输出：[1,2,4,7,5,3,6,8,9]</p><p><strong>示例 2：</strong></p><p>输入：mat &#x3D; [[1,2],[3,4]]</p><p>输出：[1,2,3,4]</p><p> </p><p><strong>提示：</strong></p><p>$m &#x3D;&#x3D; mat.length$</p><p>$n &#x3D;&#x3D; mat[i].length$</p><p>$1 &lt;&#x3D; m, n &lt;&#x3D; 104$</p><p>$1 &lt;&#x3D; m * n &lt;&#x3D; 104$</p><p>$-105 &lt;&#x3D; mat[i][j] &lt;&#x3D; 105$</p><hr><h2 id="初版"><a href="#初版" class="headerlink" title="初版"></a>初版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个Solution类来包含对角线遍历的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDiagonalOrder</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 如果矩阵为空或者不包含任何行，返回空列表</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> mat <span class="keyword">or</span> <span class="keyword">not</span> mat[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取矩阵的行数m和列数n</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 初始化结果列表</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="comment"># 设置初始位置为矩阵的左上角</span></span><br><span class="line">        row, col = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># 设置初始方向为向上</span></span><br><span class="line">        going_up = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历矩阵中的所有元素</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m * n):</span><br><span class="line">            <span class="comment"># 将当前位置的元素添加到结果列表中</span></span><br><span class="line">            result.append(mat[row][col])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果当前方向为向上</span></span><br><span class="line">            <span class="keyword">if</span> going_up:</span><br><span class="line">                <span class="comment"># 如果到达了矩阵的右边缘，向下移动一行，改变方向</span></span><br><span class="line">                <span class="keyword">if</span> col == n - <span class="number">1</span>:</span><br><span class="line">                    row += <span class="number">1</span></span><br><span class="line">                    going_up = <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 如果到达了矩阵的顶边缘，向右移动一列，改变方向</span></span><br><span class="line">                <span class="keyword">elif</span> row == <span class="number">0</span>:</span><br><span class="line">                    col += <span class="number">1</span></span><br><span class="line">                    going_up = <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 否则，向右上角移动</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    row -= <span class="number">1</span></span><br><span class="line">                    col += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果当前方向为向下</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果到达了矩阵的底边缘，向右移动一列，改变方向</span></span><br><span class="line">                <span class="keyword">if</span> row == m - <span class="number">1</span>:</span><br><span class="line">                    col += <span class="number">1</span></span><br><span class="line">                    going_up = <span class="literal">True</span></span><br><span class="line">                <span class="comment"># 如果到达了矩阵的左边缘，向下移动一行，改变方向</span></span><br><span class="line">                <span class="keyword">elif</span> col == <span class="number">0</span>:</span><br><span class="line">                    row += <span class="number">1</span></span><br><span class="line">                    going_up = <span class="literal">True</span></span><br><span class="line">                <span class="comment"># 否则，向左下角移动</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    row += <span class="number">1</span></span><br><span class="line">                    col -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打印结果列表</span></span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序入口</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建Solution类的实例</span></span><br><span class="line">    solution = Solution()</span><br><span class="line">    <span class="comment"># 调用findDiagonalOrder方法并传入一个示例矩阵</span></span><br><span class="line">    solution.findDiagonalOrder([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br></pre></td></tr></table></figure><h2 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个Solution类来包含对角线遍历的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDiagonalOrder</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 如果矩阵为空或者不包含任何行，返回空列表</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> mat <span class="keyword">or</span> <span class="keyword">not</span> mat[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取矩阵的行数m和列数n</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 初始化结果列表</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="comment"># 初始化对角线的起始点为(0, 0)</span></span><br><span class="line">        row, col = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># 总共需要遍历的对角线数量为 m + n - 1</span></span><br><span class="line">        <span class="comment"># 这是因为最左下角的元素和最右下角的元素各自形成一条对角线</span></span><br><span class="line">        <span class="keyword">for</span> diagonal <span class="keyword">in</span> <span class="built_in">range</span>(m + n - <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 为每条对角线准备一个临时子列表</span></span><br><span class="line">            temp_list = []</span><br><span class="line">            <span class="comment"># 如果对角线序号是偶数，从下向上遍历</span></span><br><span class="line">            <span class="keyword">if</span> diagonal % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 确定对角线的起始位置</span></span><br><span class="line">                <span class="comment"># 如果对角线序号小于行数，起始行是diagonal，否则是最后一行</span></span><br><span class="line">                <span class="comment"># 如果对角线序号小于列数，起始列是0，否则是diagonal减去行数加1</span></span><br><span class="line">                r, c = diagonal <span class="keyword">if</span> diagonal &lt; m <span class="keyword">else</span> m - <span class="number">1</span>, <span class="number">0</span> <span class="keyword">if</span> diagonal &lt; m <span class="keyword">else</span> diagonal - m + <span class="number">1</span></span><br><span class="line">                <span class="comment"># 循环直到行或列超出界限</span></span><br><span class="line">                <span class="keyword">while</span> r &gt;= <span class="number">0</span> <span class="keyword">and</span> c &lt; n:</span><br><span class="line">                    <span class="comment"># 将当前元素添加到临时子列表中</span></span><br><span class="line">                    temp_list.append(mat[r][c])</span><br><span class="line">                    <span class="comment"># 向上移动到对角线的下一个元素</span></span><br><span class="line">                    r, c = r - <span class="number">1</span>, c + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果对角线序号是奇数，从上向下遍历</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 确定对角线的起始位置</span></span><br><span class="line">                <span class="comment"># 如果对角线序号小于列数，起始列是diagonal，否则是最后一列</span></span><br><span class="line">                <span class="comment"># 如果对角线序号小于行数，起始行是0，否则是diagonal减去列数加1</span></span><br><span class="line">                r, c = <span class="number">0</span> <span class="keyword">if</span> diagonal &lt; n <span class="keyword">else</span> diagonal - n + <span class="number">1</span>, diagonal <span class="keyword">if</span> diagonal &lt; n <span class="keyword">else</span> n - <span class="number">1</span></span><br><span class="line">                <span class="comment"># 循环直到行或列超出界限</span></span><br><span class="line">                <span class="keyword">while</span> r &lt; m <span class="keyword">and</span> c &gt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 将当前元素添加到临时子列表中</span></span><br><span class="line">                    temp_list.append(mat[r][c])</span><br><span class="line">                    <span class="comment"># 向下移动到对角线的下一个元素</span></span><br><span class="line">                    r, c = r + <span class="number">1</span>, c - <span class="number">1</span></span><br><span class="line">            <span class="comment"># 将临时子列表添加到结果列表中</span></span><br><span class="line">            <span class="comment"># 偶数对角线不需要反转，因为它们是从下向上遍历的</span></span><br><span class="line">            result.extend(temp_list)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打印结果列表</span></span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序入口</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建Solution类的实例</span></span><br><span class="line">    solution = Solution()</span><br><span class="line">    <span class="comment"># 调用findDiagonalOrder方法并传入一个示例矩阵</span></span><br><span class="line">    solution.findDiagonalOrder([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零矩阵</title>
      <link href="/2024/04/30/%E9%9B%B6%E7%9F%A9%E9%98%B5/"/>
      <url>/2024/04/30/%E9%9B%B6%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="零矩阵"><a href="#零矩阵" class="headerlink" title="零矩阵"></a>零矩阵</h1><p>编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。</p><hr><p><strong>示例 1：</strong></p><p>输入：<br>[<br>  [1,1,1],<br>  [1,0,1],<br>  [1,1,1]<br>]</p><p>输出：<br>[<br>  [1,0,1],<br>  [0,0,0],<br>  [1,0,1]<br>]</p><p><strong>示例 2：</strong></p><p>输入：<br>[<br>  [0,1,2,0],<br>  [3,4,5,2],<br>  [1,3,1,5]<br>]</p><p>输出：<br>[<br>  [0,0,0,0],<br>  [0,4,5,0],<br>  [0,3,1,0]<br>]</p><hr><h2 id="初版"><a href="#初版" class="headerlink" title="初版"></a>初版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引入typing模块中的List类型用于类型注解</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个名为Solution的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 定义一个名为setZeroes的方法，接收一个二维整数列表matrix作为参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setZeroes</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 创建两个集合用来存储需要置零的行和列的索引</span></span><br><span class="line">        pointer_i = <span class="built_in">set</span>()</span><br><span class="line">        pointer_j = <span class="built_in">set</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取矩阵的行数和列数</span></span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历矩阵，找出所有为零的元素的行和列索引</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> matrix[i][j]:  <span class="comment"># 如果元素为零</span></span><br><span class="line">                    pointer_i.add(i)  <span class="comment"># 将行索引添加到pointer_i集合中</span></span><br><span class="line">                    pointer_j.add(j)  <span class="comment"># 将列索引添加到pointer_j集合中</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历pointer_i集合，将对应行所有元素置零</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> pointer_i:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                matrix[i][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历pointer_j集合，将对应列所有元素置零</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> pointer_j:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                matrix[i][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 打印修改后的矩阵</span></span><br><span class="line">        <span class="built_in">print</span>(matrix)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 程序的入口点</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建Solution类的实例</span></span><br><span class="line">    solution = Solution()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 调用实例的setZeroes方法，并传入一个3x4的二维数组作为参数</span></span><br><span class="line">    solution.setZeroes([</span><br><span class="line">        [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><h2 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引入typing模块中的List类型用于类型注解</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个名为Solution的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 定义一个名为setZeroes的方法，接收一个二维整数列表matrix作为参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setZeroes</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 初始化两个变量来标记第一行和第一列是否有零</span></span><br><span class="line">        <span class="comment"># 使用any函数和生成器表达式来检查第一行和第一列是否有零</span></span><br><span class="line">        first_row_zero = <span class="built_in">any</span>(matrix[<span class="number">0</span>][j] == <span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix[<span class="number">0</span>])))</span><br><span class="line">        first_col_zero = <span class="built_in">any</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历矩阵，使用第一行和第一列来标记需要置零的行和列</span></span><br><span class="line">        <span class="comment"># 从第二行和第二列开始遍历，因为第一行和第一列用于存储标记</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(matrix)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(matrix[<span class="number">0</span>])):</span><br><span class="line">                <span class="comment"># 如果当前元素为零，则将其所在行的第一个元素和所在列的第一个元素置零</span></span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 根据第一行和第一列的标记，置零除了第一行和第一列之外的元素</span></span><br><span class="line">        <span class="comment"># 再次从第二行和第二列开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(matrix)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(matrix[<span class="number">0</span>])):</span><br><span class="line">                <span class="comment"># 如果当前行的第一个元素或当前列的第一个元素为零，则将当前元素置零</span></span><br><span class="line">                <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">or</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 根据之前的标记，置零第一行和第一列</span></span><br><span class="line">        <span class="comment"># 如果first_row_zero为True，则置零第一行</span></span><br><span class="line">        <span class="keyword">if</span> first_row_zero:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix[<span class="number">0</span>])):</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 如果first_col_zero为True，则置零第一列</span></span><br><span class="line">        <span class="keyword">if</span> first_col_zero:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)):</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 打印修改后的矩阵</span></span><br><span class="line">        <span class="built_in">print</span>(matrix)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 程序的入口点</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建Solution类的实例</span></span><br><span class="line">    solution = Solution()</span><br><span class="line">    <span class="comment"># 调用实例的setZeroes方法，并传入一个3x4的二维数组作为参数</span></span><br><span class="line">    solution.setZeroes([</span><br><span class="line">        [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旋转矩阵</title>
      <link href="/2024/04/30/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/"/>
      <url>/2024/04/30/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h1><p>给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p><p>不占用额外内存空间能否做到？</p><hr><p><strong>示例 1:</strong></p><p>给定 matrix &#x3D;<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p><p>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]</p><p><strong>示例 2:</strong></p><p>给定 matrix &#x3D;<br>[<br>  [ 5, 1, 9,11],<br>  [ 2, 4, 8,10],<br>  [13, 3, 6, 7],<br>  [15,14,12,16]<br>], </p><p>原地旋转输入矩阵，使其变为:<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]</p><h2 id="初版"><a href="#初版" class="headerlink" title="初版"></a>初版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引入typing模块中的List类型用于类型注解</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个名为Solution的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 定义一个名为rotate的方法，接收一个二维整数列表matrix作为参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 获取矩阵的大小（行数和列数）</span></span><br><span class="line">        size = <span class="built_in">len</span>(matrix)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第一步：对角线对称变换，即矩阵转置</span></span><br><span class="line">        <span class="comment"># 双层循环遍历矩阵的上三角部分（包括主对角线）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, size):</span><br><span class="line">                <span class="comment"># 交换元素matrix[i][j]和matrix[j][i]</span></span><br><span class="line">                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二步：以垂直的对称轴交换每一列的元素</span></span><br><span class="line">        <span class="comment"># 遍历矩阵的前半部分列</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(size // <span class="number">2</span>):</span><br><span class="line">            <span class="comment"># 遍历矩阵的所有行</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                <span class="comment"># 交换元素matrix[i][j]和matrix[i][size - j - 1]</span></span><br><span class="line">                matrix[i][j], matrix[i][size - j - <span class="number">1</span>] = matrix[i][size - j - <span class="number">1</span>], matrix[i][j]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打印旋转后的矩阵</span></span><br><span class="line">        <span class="built_in">print</span>(matrix)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 程序的入口点</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建Solution类的实例</span></span><br><span class="line">    solution = Solution()</span><br><span class="line">    <span class="comment"># 调用实例的rotate方法，并传入一个4x4的二维数组作为参数</span></span><br><span class="line">    solution.rotate([</span><br><span class="line">        [<span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">11</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">        [<span class="number">13</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">        [<span class="number">15</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">16</span>]</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><h2 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 获取矩阵的大小（行数和列数）</span></span><br><span class="line">        size = <span class="built_in">len</span>(matrix)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第一步：对角线对称变换，即矩阵转置</span></span><br><span class="line">        <span class="comment"># 双层循环遍历矩阵的上三角部分（不包括主对角线）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, size):</span><br><span class="line">                <span class="comment"># 交换元素matrix[i][j]和matrix[j][i]</span></span><br><span class="line">                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二步：以垂直的对称轴交换每一列的元素</span></span><br><span class="line">        <span class="comment"># 遍历矩阵的前半部分列</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(size // <span class="number">2</span>):</span><br><span class="line">            <span class="comment"># 遍历矩阵的所有行</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                <span class="comment"># 交换元素matrix[i][j]和matrix[i][size - j - 1]</span></span><br><span class="line">                matrix[i][j], matrix[i][size - j - <span class="number">1</span>] = matrix[i][size - j - <span class="number">1</span>], matrix[i][j]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打印旋转后的矩阵</span></span><br><span class="line">        <span class="built_in">print</span>(matrix)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 程序的入口点</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    solution = Solution()</span><br><span class="line">    solution.rotate([</span><br><span class="line">        [<span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">11</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">        [<span class="number">13</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">        [<span class="number">15</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">16</span>]</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爱就一个字</title>
      <link href="/2024/04/29/%E7%88%B1%E5%B0%B1%E4%B8%80%E4%B8%AA%E5%AD%97/"/>
      <url>/2024/04/29/%E7%88%B1%E5%B0%B1%E4%B8%80%E4%B8%AA%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1830686080&auto=1&height=66"></iframe><p>我为你翻山越岭<br>却无心看风景<br>我想你鼓足勇气<br>凭爱的地图散播讯息<br>拨开天空的乌云<br>像蓝丝绒一样美丽<br>我为你翻山越岭<br>却无心看风景<br>我想你身不由己<br>每个念头有新的梦境<br>但愿你没忘记<br>我永远保护你<br>不管风雨的打击 全心全意<br>两个人相互辉映<br>光芒胜过夜晚繁星<br>我为你翻山越岭<br>却无心看风景<br>我想你鼓足勇气<br>凭爱的地图散播讯息<br>但愿你没忘记<br>我永远保护你<br>从此不必再流浪找寻<br>爱就一个字<br>我只说一次<br>你知道我只会用行动表示<br>野花太放肆<br>守住了坚持<br>看我为你孤注一掷<br>爱就一个字<br>我只说一次<br>恐怕听见的人勾起了相思<br>热闹的城市搜索你的影子<br>让你幸福我愿意试<br>爱就一个字<br>我只说一次<br>你知道我只会用行动表示<br>野花太放肆<br>守住了坚持<br>看我为你孤注一掷<br>爱就一个字<br>我只说一次<br>恐怕听见的人勾起了相思<br>热闹的城市搜索你的影子<br>让你幸福是我一生在乎的事</p>]]></content>
      
      
      <categories>
          
          <category> 音乐 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树和二叉树</title>
      <link href="/2024/04/29/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2024/04/29/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><h3 id="树的定义："><a href="#树的定义：" class="headerlink" title="树的定义："></a>树的定义：</h3><p>树（Tree）是n（n≥0）个节点的有限集合，它或者是空集（n&#x3D;0），或者由一个根节点及若干棵互不相交的、非空的子树组成，这些子树每一棵都是一棵树，并且它们的根节点都是这个根节点的子节点。</p><h3 id="树的基本术语："><a href="#树的基本术语：" class="headerlink" title="树的基本术语："></a>树的基本术语：</h3><ul><li><strong>节点（Node）</strong>：树中的数据元素。</li><li><strong>根节点（Root）</strong>：树中最大的节点，没有父节点。</li><li><strong>子节点（Child）</strong>：一个节点的直接后继节点。</li><li><strong>父节点（Parent）</strong>：一个节点的直接前驱节点。</li><li><strong>兄弟节点（Sibling）</strong>：具有相同父节点的节点。</li><li><strong>叶节点（Leaf）</strong>：没有子节点的节点，也称为终端节点。</li><li><strong>非叶节点（Internal Node）</strong>：至少有一个子节点的节点，也称为分支节点。</li><li><strong>节点的度（Degree）</strong>：一个节点拥有的子节点数。</li><li><strong>树的度（Degree of Tree）</strong>：树中所有节点中最大的度数。</li><li><strong>层次（Level）</strong>：根节点位于第1层，其余节点的层次等于其父节点的层次加1。</li><li><strong>深度（Depth）</strong>：节点的最大层次数。</li><li><strong>高度（Height）</strong>：节点的最大层次数，叶节点的高度为1。</li><li><strong>路径（Path）</strong>：从一个节点到另一个节点的序列。</li><li><strong>路径长度（Path Length）</strong>：路径上的边数。</li><li><strong>子树（Subtree）</strong>：树的任意节点及其后代构成的树。</li></ul><h3 id="二叉树的定义："><a href="#二叉树的定义：" class="headerlink" title="二叉树的定义："></a>二叉树的定义：</h3><p>二叉树（Binary Tree）是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。</p><h3 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h3><p>二叉树有多种特殊形式，每种形式都有其特定的属性和用途。以下是一些常见的特殊二叉树：</p><ol><li><strong>满二叉树（Full Binary Tree）</strong>：<ul><li>每个节点都有 0 个或 2 个子节点。</li><li>$在满二叉树中，每一层的节点数都是最大的，即第 i 层有 2^i 个节点。$</li></ul></li><li><strong>完全二叉树（Complete Binary Tree）</strong>：<ul><li>除了最后一层外，每一层都是满的，并且最后一层的节点都靠左排列。</li><li>可以使用数组来高效地存储完全二叉树。</li></ul></li><li><strong>完美二叉树（Perfect Binary Tree）</strong>：<ul><li>所有非叶节点都有两个子节点，并且所有叶节点都在同一层。</li><li>完美二叉树也是满二叉树和完全二叉树。</li></ul></li><li><strong>平衡二叉树（AVL Tree）</strong>：<ul><li>任何节点的两个子树的高度差（平衡因子）不超过 1。</li><li>$平衡二叉树可以保证查找、插入和删除操作的最坏情况时间复杂度为 O(log n)。$</li></ul></li><li><strong>二叉搜索树（Binary Search Tree, BST）</strong>：<ul><li>对于每个节点，其左子树中的所有节点的值都小于该节点的值，其右子树中的所有节点的值都大于该节点的值。</li><li>二叉搜索树可以用于高效的查找、插入和删除操作。</li></ul></li><li><strong>线索二叉树（Threaded Binary Tree）</strong>：<ul><li>线索二叉树是一种特殊的二叉树，它在原有的二叉树节点中添加了线索（thread），用于方便中序遍历。</li><li>线索二叉树通过将节点的空指针指向其在中序遍历中的前驱或后继节点，从而减少了对栈或递归的使用。</li></ul></li><li><strong>堆（Heap）</strong>：<ul><li>堆是一种特殊的完全二叉树，通常用于实现优先队列。</li><li>最大堆（Max Heap）：任何一个父节点的值都大于或等于其子节点的值。</li><li>最小堆（Min Heap）：任何一个父节点的值都小于或等于其子节点的值。</li></ul></li><li><strong>霍夫曼树（Huffman Tree）</strong>：<ul><li>霍夫曼树是一种带权路径长度最短的二叉树，也称为最优二叉树。</li><li>它通常用于数据压缩，如霍夫曼编码。<br>这些特殊形式的二叉树在不同的应用场景中有不同的优化效果和用途。例如，平衡二叉树用于提高查找效率，堆用于实现优先队列，霍夫曼树用于数据压缩等。</li></ul></li></ol><h3 id="二叉树的性质："><a href="#二叉树的性质：" class="headerlink" title="二叉树的性质："></a>二叉树的性质：</h3><ol><li><strong>第$i$层最多有$2^i-1$个节点（i≥1）。</strong></li><li><strong>深度为$k$的二叉树最多有$2^k-1$个节点$（k≥1）$。</strong></li><li><strong>在完全二叉树中，若从上至下、从左至右编号，则编号为$i（i≥1）$的节点，其父节点编号为$i&#x2F;2$（$i&#x3D;1$时为根节点），其左子节点编号为$2i$，其右子节点编号为$2i+1$；若$2i$大于节点总数，则无左子节点；若$2i+1$大于节点总数，则无右子节点。</strong></li><li><strong>对于任何非空二叉树，若$n_0$表示叶节点数，$n_1$表示度为1的节点数，$n_2$表示度为2的节点数，则有$n_0&#x3D;n_2+1。$</strong></li><li><strong>对于一棵有$n$个节点的完全二叉树，其深度$d$满足$2^{k-1}≤n≤2^k-1$。这意味着$k-1&lt;&#x3D;log_2n&lt;k$，因为$k$是整数，所以$k&#x3D;|log_2n|+1。$</strong></li></ol><h3 id="二叉树的存储结构："><a href="#二叉树的存储结构：" class="headerlink" title="二叉树的存储结构："></a>二叉树的存储结构：</h3><p><strong>顺序存储结构</strong>：使用数组来存储二叉树，适用于完全二叉树或近似完全二叉树，因为这种存储方式会浪费空间。</p><p>二叉树的顺序存储结构是指使用数组来存储二叉树中的节点。在这种存储方式中，树中的节点按照一定的顺序放置在数组中，通常采用的是层序遍历的顺序。以下是顺序存储结构的一些关键点：</p><ol><li><strong>数组索引</strong>：在顺序存储结构中，数组的第一个元素（索引为0的位置）通常不使用，这样可以使得对于任意节点i，其左孩子节点在数组中的位置是2i，右孩子节点在数组中的位置是2i+1。同样，节点i的父节点在数组中的位置是i&#x2F;2（向下取整）。</li><li><strong>完全二叉树</strong>：顺序存储结构特别适合完全二叉树，因为完全二叉树的节点顺序与数组的索引顺序完美对应，不会浪费数组空间。</li><li><strong>非完全二叉树</strong>：对于非完全二叉树，顺序存储结构可能会浪费一些数组空间，因为数组需要为可能不存在的节点保留位置。</li><li><strong>存储内容</strong>：数组中存储的可以是节点的值，也可以是节点的引用或指针，这取决于具体的编程语言和实现方式。</li><li><strong>遍历操作</strong>：顺序存储的二叉树可以通过简单的数组索引操作来进行遍历，例如，层序遍历可以通过顺序访问数组元素来实现。</li><li><strong>空间复杂度</strong>：顺序存储结构的空间复杂度是O(n)，其中n是树中节点的数量。这意味着它需要足够的连续内存来存储整个树。</li><li><strong>动态调整</strong>：如果二叉树的结构经常发生变化（如插入或删除节点），那么顺序存储结构可能不太适合，因为这样的操作可能需要移动数组中的大量元素。</li><li><strong>应用</strong>：顺序存储结构在堆（特别是二叉堆）的实现中非常常见，因为堆是一种特殊的完全二叉树，它的操作（如插入、删除、建堆等）可以通过数组的索引来高效地实现。<br>顺序存储结构的优点是它的存储密度高，访问速度快，特别适合于完全二叉树。然而，对于非完全二叉树，它可能不如链式存储结构灵活。</li></ol><p><strong>链式存储结构</strong>：使用链表来存储二叉树，每个节点包含值、左子指针和右子指针。这种存储方式不会浪费空间，但访问节点时需要遍历树。</p><p>二叉树的链式存储结构是指使用节点和指针来表示二叉树中的每个节点及其关系的存储方式。在这种存储方式中，每个节点通常包含三个部分：数据域、左子指针和右子指针。以下是链式存储结构的一些关键点：</p><ol><li><strong>节点结构</strong>：每个节点包含一个数据域，用于存储节点的值，以及两个指针域，分别指向左子节点和右子节点。如果某个子节点不存在，相应的指针将为null。</li><li><strong>动态结构</strong>：链式存储结构可以很好地处理动态变化的二叉树，因为节点的添加和删除只需要改变相应的指针，而不需要移动大量数据。</li><li><strong>空间效率</strong>：链式存储结构不会像顺序存储结构那样浪费空间，因为它只为实际存在的节点分配内存。</li><li><strong>遍历操作</strong>：链式存储的二叉树可以通过递归或迭代的方式来进行遍历，例如前序遍历、中序遍历和后序遍历。</li><li><strong>存储内容</strong>：链式存储的节点可以存储任何类型的数据，并且可以很容易地扩展节点的结构和功能。</li><li><strong>空间复杂度</strong>：链式存储结构的空间复杂度也是O(n)，其中n是树中节点的数量。但是，它不需要连续的内存空间，因此可以更好地处理大型树或动态变化的树。</li><li><strong>应用</strong>：链式存储结构在二叉搜索树、平衡二叉树（如AVL树和红黑树）以及其他各种二叉树结构中非常常见。<br>链式存储结构的优点是它的灵活性高，可以表示各种形状和大小的二叉树，且对树的修改操作较为方便。然而，相比顺序存储结构，链式存储结构在访问特定节点时可能需要更多的指针跳转，因此访问速度可能稍慢。</li></ol><h3 id="遍历二叉树和线索而二叉树"><a href="#遍历二叉树和线索而二叉树" class="headerlink" title="遍历二叉树和线索而二叉树"></a>遍历二叉树和线索而二叉树</h3><p>遍历二叉树是访问树中所有节点的过程。对于二叉树，有几种经典的遍历方法，每种方法都有其特定的访问顺序。以下是二叉树的几种常见遍历方式：</p><ol><li><strong>前序遍历（Preorder Traversal）</strong>：<ul><li>访问顺序：根节点 -&gt; 左子树 -&gt; 右子树</li><li>操作步骤：<ol><li>访问当前节点。</li><li>前序遍历左子树。</li><li>前序遍历右子树。</li></ol></li></ul></li><li><strong>中序遍历（Inorder Traversal）</strong>：<ul><li>访问顺序：左子树 -&gt; 根节点 -&gt; 右子树</li><li>操作步骤：<ol><li>中序遍历左子树。</li><li>访问当前节点。</li><li>中序遍历右子树。</li></ol></li></ul></li><li><strong>后序遍历（Postorder Traversal）</strong>：<ul><li>访问顺序：左子树 -&gt; 右子树 -&gt; 根节点</li><li>操作步骤：<ol><li>后序遍历左子树。</li><li>后序遍历右子树。</li><li>访问当前节点。</li></ol></li></ul></li><li><strong>层序遍历（Level Order Traversal）</strong>：<ul><li>访问顺序：从上到下、从左到右，按层级访问每个节点</li><li>操作步骤：<ol><li>创建一个队列。</li><li>将根节点入队。</li><li>当队列不为空时，重复以下步骤：<ul><li>出队一个节点，访问它。</li><li>将该节点的左子节点入队。</li><li>将该节点的右子节点入队。<br>遍历二叉树可以使用递归或迭代的方法。递归方法通常更直观，迭代方法则需要使用栈或队列来手动模拟递归过程。<br>遍历二叉树是二叉树操作的基础，它不仅可以用于打印节点的值，还可以用于各种计算和操作，如求树的节点数、求树的深度、查找特定值的节点等。</li></ul></li></ol></li></ul></li></ol><h4 id="递归代码实现"><a href="#递归代码实现" class="headerlink" title="递归代码实现"></a>递归代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义二叉树节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.val = value  <span class="comment"># 节点存储的值</span></span><br><span class="line">        self.left = <span class="literal">None</span>  <span class="comment"># 左子节点引用</span></span><br><span class="line">        self.right = <span class="literal">None</span>  <span class="comment"># 右子节点引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前序遍历</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preorder_traversal</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果当前节点为空，则返回</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(root.val, end=<span class="string">&#x27; &#x27;</span>)  <span class="comment"># 打印当前节点的值</span></span><br><span class="line">    preorder_traversal(root.left)  <span class="comment"># 递归遍历左子树</span></span><br><span class="line">    preorder_traversal(root.right)  <span class="comment"># 递归遍历右子树</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 中序遍历</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inorder_traversal</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果当前节点为空，则返回</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    inorder_traversal(root.left)  <span class="comment"># 递归遍历左子树</span></span><br><span class="line">    <span class="built_in">print</span>(root.val, end=<span class="string">&#x27; &#x27;</span>)  <span class="comment"># 打印当前节点的值</span></span><br><span class="line">    inorder_traversal(root.right)  <span class="comment"># 递归遍历右子树</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 后序遍历</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">postorder_traversal</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果当前节点为空，则返回</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    postorder_traversal(root.left)  <span class="comment"># 递归遍历左子树</span></span><br><span class="line">    postorder_traversal(root.right)  <span class="comment"># 递归遍历右子树</span></span><br><span class="line">    <span class="built_in">print</span>(root.val, end=<span class="string">&#x27; &#x27;</span>)  <span class="comment"># 打印当前节点的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 层序遍历</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">levelorder_traversal</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果当前节点为空，则返回</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    queue = deque([root])  <span class="comment"># 创建一个双端队列，并将根节点入队</span></span><br><span class="line">    <span class="keyword">while</span> queue:  <span class="comment"># 当队列不为空时，循环继续</span></span><br><span class="line">        node = queue.popleft()  <span class="comment"># 出队一个节点</span></span><br><span class="line">        <span class="built_in">print</span>(node.val, end=<span class="string">&#x27; &#x27;</span>)  <span class="comment"># 打印节点的值</span></span><br><span class="line">        <span class="keyword">if</span> node.left:  <span class="comment"># 如果左子节点存在，则入队</span></span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:  <span class="comment"># 如果右子节点存在，则入队</span></span><br><span class="line">            queue.append(node.right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个简单的二叉树</span></span><br><span class="line"><span class="comment">#       1</span></span><br><span class="line"><span class="comment">#      / \</span></span><br><span class="line"><span class="comment">#     2   3</span></span><br><span class="line"><span class="comment">#    / \</span></span><br><span class="line"><span class="comment">#   4   5</span></span><br><span class="line">root = TreeNode(<span class="number">1</span>)</span><br><span class="line">root.left = TreeNode(<span class="number">2</span>)</span><br><span class="line">root.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">root.left.left = TreeNode(<span class="number">4</span>)</span><br><span class="line">root.left.right = TreeNode(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行遍历</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Preorder Traversal:&quot;</span>); preorder_traversal(root); <span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Inorder Traversal:&quot;</span>); inorder_traversal(root); <span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Postorder Traversal:&quot;</span>); postorder_traversal(root); <span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Levelorder Traversal:&quot;</span>); levelorder_traversal(root); <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Preorder Traversal:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> </span><br><span class="line">Inorder Traversal:</span><br><span class="line"><span class="number">4</span> <span class="number">2</span> <span class="number">5</span> <span class="number">1</span> <span class="number">3</span> </span><br><span class="line">Postorder Traversal:</span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> </span><br><span class="line">Levelorder Traversal:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="非递归代码实现"><a href="#非递归代码实现" class="headerlink" title="非递归代码实现"></a>非递归代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义二叉树节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.val = value  <span class="comment"># 节点存储的值</span></span><br><span class="line">        self.left = <span class="literal">None</span>  <span class="comment"># 左子节点引用</span></span><br><span class="line">        self.right = <span class="literal">None</span>  <span class="comment"># 右子节点引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前序遍历（非递归）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preorder_traversal_iterative</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    stack = [root]  <span class="comment"># 使用栈来模拟递归过程，首先将根节点入栈</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()  <span class="comment"># 出栈一个节点</span></span><br><span class="line">        <span class="built_in">print</span>(node.val, end=<span class="string">&#x27; &#x27;</span>)  <span class="comment"># 打印当前节点的值</span></span><br><span class="line">        <span class="comment"># 先将右子节点入栈，再将左子节点入栈，这样可以保证左子节点先被访问</span></span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中序遍历（非递归）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inorder_traversal_iterative</span>(<span class="params">root</span>):</span><br><span class="line">    stack, node = [], root  <span class="comment"># 初始化栈和节点指针</span></span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">or</span> node:</span><br><span class="line">        <span class="keyword">while</span> node:  <span class="comment"># 将所有左子节点入栈</span></span><br><span class="line">            stack.append(node)</span><br><span class="line">            node = node.left</span><br><span class="line">        node = stack.pop()  <span class="comment"># 出栈一个节点</span></span><br><span class="line">        <span class="built_in">print</span>(node.val, end=<span class="string">&#x27; &#x27;</span>)  <span class="comment"># 打印当前节点的值</span></span><br><span class="line">        node = node.right  <span class="comment"># 移动到右子节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 后序遍历（非递归）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">postorder_traversal_iterative</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    后序遍历二叉树的非递归实现。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param root: 二叉树的根节点</span></span><br><span class="line"><span class="string">    :return: 后序遍历的结果列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 初始化结果列表</span></span><br><span class="line">    result = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用栈来辅助遍历</span></span><br><span class="line">    stack = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当前节点和上一个访问的节点</span></span><br><span class="line">    current = root</span><br><span class="line">    last_visited = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当前节点不为空或栈不为空时，继续遍历</span></span><br><span class="line">    <span class="keyword">while</span> current <span class="keyword">or</span> stack:</span><br><span class="line">        <span class="comment"># 将当前节点的所有左子节点入栈</span></span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            stack.append(current)</span><br><span class="line">            current = current.left</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 取出栈顶元素</span></span><br><span class="line">        current = stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果当前节点没有右子节点，或者右子节点已经被访问过</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> current.right <span class="keyword">or</span> current.right == last_visited:</span><br><span class="line">            <span class="comment"># 访问当前节点</span></span><br><span class="line">            result.append(current.val)</span><br><span class="line">            <span class="comment"># 将当前节点标记为已访问</span></span><br><span class="line">            last_visited = current</span><br><span class="line">            <span class="comment"># 弹出当前节点</span></span><br><span class="line">            stack.pop()</span><br><span class="line">            <span class="comment"># 将当前节点置为None，以便继续弹出栈顶元素</span></span><br><span class="line">            current = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 否则，继续遍历右子树</span></span><br><span class="line">            current = current.right</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(*result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个简单的二叉树</span></span><br><span class="line"><span class="comment">#       1</span></span><br><span class="line"><span class="comment">#      / \</span></span><br><span class="line"><span class="comment">#     2   3</span></span><br><span class="line"><span class="comment">#    / \</span></span><br><span class="line"><span class="comment">#   4   5</span></span><br><span class="line">root = TreeNode(<span class="number">1</span>)</span><br><span class="line">root.left = TreeNode(<span class="number">2</span>)</span><br><span class="line">root.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">root.left.left = TreeNode(<span class="number">4</span>)</span><br><span class="line">root.left.right = TreeNode(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行遍历</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Preorder Traversal (Iterative):&quot;</span>)</span><br><span class="line">preorder_traversal_iterative(root)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Inorder Traversal (Iterative):&quot;</span>)</span><br><span class="line">inorder_traversal_iterative(root)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Postorder Traversal (Iterative):&quot;</span>)</span><br><span class="line">postorder_traversal_iterative(root)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Preorder Traversal (Iterative):</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> </span><br><span class="line">Inorder Traversal (Iterative):</span><br><span class="line"><span class="number">4</span> <span class="number">2</span> <span class="number">5</span> <span class="number">1</span> <span class="number">3</span> </span><br><span class="line">Postorder Traversal (Iterative):</span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="创建二叉树"><a href="#创建二叉树" class="headerlink" title="创建二叉树"></a>创建二叉树</h4><h5 id="按照先序遍历的顺序建立二叉链表"><a href="#按照先序遍历的顺序建立二叉链表" class="headerlink" title="按照先序遍历的顺序建立二叉链表"></a>按照先序遍历的顺序建立二叉链表</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data=<span class="literal">None</span>, lchild=<span class="literal">None</span>, rchild=<span class="literal">None</span></span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.lchild = lchild</span><br><span class="line">        self.rchild = rchild</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_bitree</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 按先序次序输入二叉树中节点的值（单字符），创建二叉链表表示的二叉树</span></span><br><span class="line">        ch = <span class="built_in">input</span>()</span><br><span class="line">        <span class="keyword">if</span> ch == <span class="string">&quot;#&quot;</span>:  <span class="comment"># 递归结束，建立空树</span></span><br><span class="line">            self.data = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 递归创建二叉树</span></span><br><span class="line">            self.data = ch  <span class="comment"># 根节点的数据域赋值为ch</span></span><br><span class="line">            self.lchild = BinaryTree()  <span class="comment"># 为当前节点创建一个空的左子树</span></span><br><span class="line">            self.lchild.create_bitree()  <span class="comment"># 递归创建左子树</span></span><br><span class="line">            self.rchild = BinaryTree()  <span class="comment"># 为当前节点创建一个空的右子树</span></span><br><span class="line">            self.rchild.create_bitree()  <span class="comment"># 递归创建右子树</span></span><br></pre></td></tr></table></figure><h5 id="层次创建二叉树"><a href="#层次创建二叉树" class="headerlink" title="层次创建二叉树"></a>层次创建二叉树</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义树的节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value=<span class="number">0</span></span>):</span><br><span class="line">        self.value = value  <span class="comment"># 节点存储的值</span></span><br><span class="line">        self.left = <span class="literal">None</span>    <span class="comment"># 左子节点</span></span><br><span class="line">        self.right = <span class="literal">None</span>   <span class="comment"># 右子节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据层次遍历的输入创建二叉树</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_binary_tree</span>(<span class="params">level_order</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> level_order:  <span class="comment"># 如果层次遍历输入为空，返回None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    root = TreeNode(level_order[<span class="number">0</span>])  <span class="comment"># 创建根节点</span></span><br><span class="line">    queue = deque([root])  <span class="comment"># 使用双端队列存储节点，初始时只有根节点</span></span><br><span class="line">    index = <span class="number">1</span>  <span class="comment"># 初始化索引，指向层次遍历输入的下一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue <span class="keyword">and</span> index &lt; <span class="built_in">len</span>(level_order):  <span class="comment"># 当队列不为空且索引未超出输入长度时继续</span></span><br><span class="line">        current = queue.popleft()  <span class="comment"># 从队列中取出一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理左子节点</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="built_in">len</span>(level_order) <span class="keyword">and</span> level_order[index] != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">            current.left = TreeNode(level_order[index])  <span class="comment"># 创建左子节点</span></span><br><span class="line">            queue.append(current.left)  <span class="comment"># 将新创建的左子节点加入队列</span></span><br><span class="line">        index += <span class="number">1</span>  <span class="comment"># 移动索引到下一个元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理右子节点</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="built_in">len</span>(level_order) <span class="keyword">and</span> level_order[index] != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">            current.right = TreeNode(level_order[index])  <span class="comment"># 创建右子节点</span></span><br><span class="line">            queue.append(current.right)  <span class="comment"># 将新创建的右子节点加入队列</span></span><br><span class="line">        index += <span class="number">1</span>  <span class="comment"># 再次移动索引到下一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root  <span class="comment"># 返回创建好的树的根节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法：</span></span><br><span class="line">level_order_input = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>]  <span class="comment"># 层次遍历的输入</span></span><br><span class="line">root = create_binary_tree(level_order_input)  <span class="comment"># 创建二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 层次遍历二叉树以可视化树结构</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">level_order_traversal</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:  <span class="comment"># 如果根节点为空，返回空列表</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    result = []  <span class="comment"># 存储层次遍历的结果</span></span><br><span class="line">    queue = deque([root])  <span class="comment"># 使用双端队列进行层次遍历，初始时只有根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue:  <span class="comment"># 当队列不为空时继续</span></span><br><span class="line">        current = queue.popleft()  <span class="comment"># 从队列中取出一个节点</span></span><br><span class="line">        result.append(current.value)  <span class="comment"># 将节点的值加入结果列表</span></span><br><span class="line">        <span class="keyword">if</span> current.left:  <span class="comment"># 如果存在左子节点，加入队列</span></span><br><span class="line">            queue.append(current.left)</span><br><span class="line">        <span class="keyword">if</span> current.right:  <span class="comment"># 如果存在右子节点，加入队列</span></span><br><span class="line">            queue.append(current.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result  <span class="comment"># 返回层次遍历的结果</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(level_order_traversal(root))  <span class="comment"># 打印层次遍历的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>]</span><br></pre></td></tr></table></figure><h4 id="二叉树遍历算法的应用"><a href="#二叉树遍历算法的应用" class="headerlink" title="二叉树遍历算法的应用"></a>二叉树遍历算法的应用</h4><h5 id="复制二叉树"><a href="#复制二叉树" class="headerlink" title="复制二叉树"></a>复制二叉树</h5><p>复制二叉树的函数会递归地创建一个新的树，其结构和原始树相同，每个节点的值也相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">copy</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="comment"># 复制一颗完全相同的二叉树</span></span><br><span class="line">    <span class="keyword">if</span> t.data <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        tree = BinaryTree()  <span class="comment"># 如果是空树，生成一棵空树，递归结束</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        tree = BinaryTree(t.data)  <span class="comment"># 申请一个新节点的空间，复制根节点</span></span><br><span class="line">        tree.lchild = copy(t.lchild)  <span class="comment"># 递归复制左节点</span></span><br><span class="line">        tree.rchile = copy(t.rchild)  <span class="comment"># 递归复制右节点</span></span><br><span class="line">    <span class="keyword">return</span> tree</span><br></pre></td></tr></table></figure><h5 id="计算二叉树的深度"><a href="#计算二叉树的深度" class="headerlink" title="计算二叉树的深度"></a>计算二叉树的深度</h5><p>计算二叉树的深度可以通过递归地计算左右子树的深度，然后取最大值加一来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">depth_binary_tree</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="comment"># 如果当前节点为空，表示已经到达叶子节点以下的空节点，返回深度0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归计算左子树的深度</span></span><br><span class="line">    left_depth = depth_binary_tree(root.left)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归计算右子树的深度</span></span><br><span class="line">    right_depth = depth_binary_tree(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当前节点的深度是其左右子树深度的最大值加1（因为要包括当前这一层）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left_depth, right_depth) + <span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="统计二叉树中节点的个数"><a href="#统计二叉树中节点的个数" class="headerlink" title="统计二叉树中节点的个数"></a>统计二叉树中节点的个数</h5><p>统计二叉树中节点的个数可以通过递归地计算左右子树的节点数，然后将它们加上根节点的数量1来实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_nodes</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="comment"># 如果当前节点为空，表示已经到达叶子节点以下的空节点，返回节点数0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归计算左子树的节点数</span></span><br><span class="line">    left_count = count_nodes(root.left)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归计算右子树的节点数</span></span><br><span class="line">    right_count = count_nodes(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当前节点的总数是其左右子树节点数之和加1（因为要包括当前节点）</span></span><br><span class="line">    <span class="keyword">return</span> left_count + right_count + <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并区间</title>
      <link href="/2024/04/29/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
      <url>/2024/04/29/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h1><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><p> </p><p>示例 1：</p><p>输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br>示例 2：</p><p>输入：intervals &#x3D; [[1,4],[4,5]]<br>输出：[[1,5]]<br>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。 </p><p>提示：</p><p>$1 &lt;&#x3D; intervals.length &lt;&#x3D; 104$<br>$intervals[i].length &#x3D;&#x3D; 2$<br>$0 &lt;&#x3D; start_i &lt;&#x3D; end_i &lt;&#x3D; 104$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">intervals</span>):</span><br><span class="line">    <span class="comment"># 先根据每个区间的起始点进行排序</span></span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    merged = []</span><br><span class="line">    <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">        <span class="comment"># 如果合并的区间列表为空或当前区间不与前一个区间重叠，直接添加</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> merged <span class="keyword">or</span> merged[-<span class="number">1</span>][<span class="number">1</span>] &lt; interval[<span class="number">0</span>]:</span><br><span class="line">            merged.append(interval)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 否则，合并区间，只需更新结束点</span></span><br><span class="line">            merged[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(merged[-<span class="number">1</span>][<span class="number">1</span>], interval[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> merged</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">intervals = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line"><span class="built_in">print</span>(merge(intervals))  <span class="comment"># 输出: [[1,6],[8,10],[15,18]]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索插入位置</title>
      <link href="/2024/04/29/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
      <url>/2024/04/29/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>请必须使用时间复杂度为 O(log n) 的算法。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a>示例 3:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><h2 id="初版"><a href="#初版" class="headerlink" title="初版"></a>初版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span>                       <span class="comment"># 初始化左指针</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span>          <span class="comment"># 初始化右指针到数组最后一个元素的索引</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span>      <span class="comment"># 计算中间位置的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left != right:           <span class="comment"># 当左指针不等于右指针时，循环继续</span></span><br><span class="line">            <span class="comment"># 如果目标元素小于中间位置的元素，说明目标元素在数组的左侧</span></span><br><span class="line">            <span class="keyword">if</span> target &lt; nums[mid]:</span><br><span class="line">                right = mid            <span class="comment"># 将右指针移动到中间位置的前一个位置</span></span><br><span class="line">                mid = (left + right) // <span class="number">2</span>  <span class="comment"># 重新计算中间位置</span></span><br><span class="line">            <span class="comment"># 如果目标元素大于中间位置的元素，说明目标元素在数组的右侧</span></span><br><span class="line">            <span class="keyword">elif</span> target &gt; nums[mid]:</span><br><span class="line">                left = mid + <span class="number">1</span>         <span class="comment"># 将左指针移动到中间位置的下一个位置</span></span><br><span class="line">                mid = (left + right) // <span class="number">2</span>  <span class="comment"># 重新计算中间位置</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> mid             <span class="comment"># 如果目标元素等于中间位置的元素，返回中间位置的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当左指针等于右指针时，循环结束</span></span><br><span class="line">        <span class="comment"># 此时需要确定目标元素的插入位置</span></span><br><span class="line">        <span class="keyword">if</span> nums[left] &lt; target:</span><br><span class="line">            <span class="keyword">return</span> left + <span class="number">1</span>            <span class="comment"># 如果目标元素大于当前左指针指向的元素，插入位置为左指针的下一个位置</span></span><br><span class="line">        <span class="keyword">elif</span> nums[left] &gt; target:</span><br><span class="line">            <span class="keyword">return</span> left                <span class="comment"># 如果目标元素小于当前左指针指向的元素，插入位置为左指针的位置</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> left                <span class="comment"># 如果目标元素等于当前左指针指向的元素，插入位置为左指针的位置</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span>                       <span class="comment"># 初始化左指针</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span>          <span class="comment"># 初始化右指针到数组最后一个元素的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:           <span class="comment"># 当左指针小于或等于右指针时，循环继续</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span>  <span class="comment"># 计算中间位置的索引</span></span><br><span class="line">            <span class="comment"># 如果目标元素小于中间位置的元素，说明目标元素在数组的左侧</span></span><br><span class="line">            <span class="keyword">if</span> target &lt; nums[mid]:</span><br><span class="line">                right = mid - <span class="number">1</span>        <span class="comment"># 将右指针移动到中间位置的前一个位置</span></span><br><span class="line">            <span class="comment"># 如果目标元素大于中间位置的元素，说明目标元素在数组的右侧</span></span><br><span class="line">            <span class="keyword">elif</span> target &gt; nums[mid]:</span><br><span class="line">                left = mid + <span class="number">1</span>         <span class="comment"># 将左指针移动到中间位置的下一个位置</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> mid             <span class="comment"># 如果目标元素等于中间位置的元素，返回中间位置的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果目标元素不在数组中，left 和 right 会指向同一个位置</span></span><br><span class="line">        <span class="comment"># 此时 left（或 right）指向的位置就是目标元素的插入位置</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻找数组的中心索引</title>
      <link href="/2024/04/29/%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/"/>
      <url>/2024/04/29/%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="寻找数组的中心索引"><a href="#寻找数组的中心索引" class="headerlink" title="寻找数组的中心索引"></a>寻找数组的中心索引</h1><p>给你一个整数数组 nums ，请计算数组的 中心下标 。数组中心下标是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。<br>如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。<br>如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1, 7, 3, 6, 5, 6]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">中心下标是 3 。</span><br><span class="line">左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，</span><br><span class="line">右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。</span><br></pre></td></tr></table></figure><h2 id="普通版本"><a href="#普通版本" class="headerlink" title="普通版本"></a>普通版本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(nums[:i]) == <span class="built_in">sum</span>(nums[i+<span class="number">1</span>:]):</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="优化版本"><a href="#优化版本" class="headerlink" title="优化版本"></a>优化版本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 首先计算整个数组的总和</span></span><br><span class="line">        total_sum = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="comment"># 初始化左侧总和为0</span></span><br><span class="line">        left_sum = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历数组中的每个索引</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 从总和中减去当前元素，得到右侧总和</span></span><br><span class="line">            total_sum -= nums[i]</span><br><span class="line">            <span class="comment"># 如果左侧总和等于右侧总和，那么当前索引就是中心索引</span></span><br><span class="line">            <span class="keyword">if</span> left_sum == total_sum:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            <span class="comment"># 将当前元素加到左侧总和中</span></span><br><span class="line">            left_sum += nums[i]</span><br><span class="line">        <span class="comment"># 如果没有找到中心索引，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初等变换与秩</title>
      <link href="/2024/04/29/%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%A7%A9/"/>
      <url>/2024/04/29/%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%A7%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="初等变换与秩"><a href="#初等变换与秩" class="headerlink" title="初等变换与秩"></a>初等变换与秩</h1><p><img src="https://sfile.chatglm.cn/chatglm4/b99819db-3def-4927-92fd-65fca57bc912.png?image_process=format,webp"></p><h1 id="什么是初等变换？"><a href="#什么是初等变换？" class="headerlink" title="什么是初等变换？"></a>什么是初等变换？</h1><p>初等矩阵是一种特殊的矩阵，它们与初等行（列）变换密切相关。在矩阵理论中，任何一个矩阵都可以通过一系列的初等行（列）变换转换成行最简形式或列最简形式。这些变换是由初等矩阵来实现的。<br>一个 ( $m \times n $) 的矩阵，如果它只由单位矩阵经过一次初等变换得到，那么这样的矩阵就称为初等矩阵。具体来说，初等矩阵可以分为三类：</p><ol><li><strong>互换两行（两列）的初等矩阵</strong>：将单位矩阵中的任意两行（两列）互换，所得到的矩阵就是这种类型的初等矩阵。</li><li><strong>以非零常数乘以某一行（列）的初等矩阵</strong>：将单位矩阵中的某一行（列）的每一个元素乘以一个非零常数，所得到的矩阵就是这种类型的初等矩阵。</li><li><strong>将一行（列）的某个倍数加到另一行（列）上</strong>：将单位矩阵中的某一行（列）的每个元素乘以一个常数后加到另一行（列）的对应元素上，所得到的矩阵就是这种类型的初等矩阵。</li></ol><p>在矩阵的行最简形式中，每一行的第一个非零数字都是1，且这个1所在的列中其他行的元素都是0。初等矩阵的逆矩阵仍然是初等矩阵，而且初等矩阵的乘积也是初等矩阵。</p><p><img src="https://sfile.chatglm.cn/chatglm4/e7f5d21e-e798-4042-a9ff-2e9ad96c8588.png?image_process=format,webp"></p><h1 id="什么是矩阵等价？"><a href="#什么是矩阵等价？" class="headerlink" title="什么是矩阵等价？"></a>什么是矩阵等价？</h1><p><img src="https://sfile.chatglm.cn/chatglm4/669e3f0d-ce7c-40eb-808e-81403441494f.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/ed191e74-f3ee-4998-bfb3-fb6a511fd58f.png?image_process=format,webp"></p><h1 id="用矩阵乘法表示初等变换"><a href="#用矩阵乘法表示初等变换" class="headerlink" title="用矩阵乘法表示初等变换"></a>用矩阵乘法表示初等变换</h1><p><img src="https://sfile.chatglm.cn/chatglm4/cd25ce14-8d71-4048-850a-01b90dbb84cc.png?image_process=format,webp"></p><h1 id="初等矩阵的逆"><a href="#初等矩阵的逆" class="headerlink" title="初等矩阵的逆"></a>初等矩阵的逆</h1><p><img src="https://sfile.chatglm.cn/chatglm4/9006f81a-4857-4b2a-a0ef-320fa638d532.png?image_process=format,webp"></p><h1 id="初等变换求逆"><a href="#初等变换求逆" class="headerlink" title="初等变换求逆"></a>初等变换求逆</h1><p><img src="https://sfile.chatglm.cn/chatglm4/23d829d1-8d77-4604-8819-25f5332fb6a1.png?image_process=format,webp"></p><h2 id="eg"><a href="#eg" class="headerlink" title="eg"></a>eg</h2><p><img src="https://sfile.chatglm.cn/chatglm4/65b7a52e-9524-4e99-9a29-cbc6c75c2be8.png?image_process=format,webp"></p><h1 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h1><p><img src="https://sfile.chatglm.cn/chatglm4/c06ce686-5deb-4bfd-a9cd-0c44eb25b12b.png?image_process=format,webp"></p><h1 id="求矩阵的秩"><a href="#求矩阵的秩" class="headerlink" title="求矩阵的秩"></a>求矩阵的秩</h1><p><img src="https://sfile.chatglm.cn/chatglm4/0fcf86f7-1b72-4a17-bdb9-20be51bba7e5.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/ceebbeb3-85e7-4685-abc3-b5c600a46b63.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/5a0f8cfe-d1ec-4b16-b8e9-4ae1250a939f.png?image_process=format,webp"></p><h1 id="秩的公式大总结"><a href="#秩的公式大总结" class="headerlink" title="秩的公式大总结"></a>秩的公式大总结</h1><h2 id="转置不改变秩"><a href="#转置不改变秩" class="headerlink" title="转置不改变秩"></a>转置不改变秩</h2><p><img src="https://sfile.chatglm.cn/chatglm4/dd2b23fe-d926-4cc6-878c-2430839eaa74.png?image_process=format,webp"></p><h2 id="秩不大于行数-列数"><a href="#秩不大于行数-列数" class="headerlink" title="秩不大于行数&#x2F;列数"></a>秩不大于行数&#x2F;列数</h2><p><img src="https://sfile.chatglm.cn/chatglm4/83a30ba6-71a6-4a83-867b-6ab64dc10fba.png?image_process=format,webp"></p><h2 id="可逆变换不改变秩"><a href="#可逆变换不改变秩" class="headerlink" title="可逆变换不改变秩"></a>可逆变换不改变秩</h2><p><img src="https://sfile.chatglm.cn/chatglm4/123dce95-8456-4c52-9830-1f928881cfba.png?image_process=format,webp"></p><h2 id="秩越乘越小，越拼越大，分开加最大"><a href="#秩越乘越小，越拼越大，分开加最大" class="headerlink" title="秩越乘越小，越拼越大，分开加最大"></a>秩越乘越小，越拼越大，分开加最大</h2><p><img src="https://sfile.chatglm.cn/chatglm4/19d1f7d8-395f-4bab-b6a5-8b65397278e2.png?image_process=format,webp"></p><h2 id="矩阵相乘等于零"><a href="#矩阵相乘等于零" class="headerlink" title="矩阵相乘等于零"></a>矩阵相乘等于零</h2><p><img src="https://sfile.chatglm.cn/chatglm4/5d60a93e-1fc9-4002-bdd1-190b9562630a.png?image_process=format,webp"></p><hr><p><img src="https://sfile.chatglm.cn/chatglm4/1640c54d-90c4-4ef0-ba93-072e0a2e9818.png?image_process=format,webp"></p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵的公式</title>
      <link href="/2024/04/29/%E7%9F%A9%E9%98%B5%E7%9A%84%E5%85%AC%E5%BC%8F/"/>
      <url>/2024/04/29/%E7%9F%A9%E9%98%B5%E7%9A%84%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="矩阵的公式"><a href="#矩阵的公式" class="headerlink" title="矩阵的公式"></a>矩阵的公式</h1><p><img src="https://sfile.chatglm.cn/chatglm4/59e6073f-feae-4a1d-9597-b491d9d21a83.png?image_process=format,webp"></p><hr><h1 id="矩阵公式大总结"><a href="#矩阵公式大总结" class="headerlink" title="矩阵公式大总结"></a>矩阵公式大总结</h1><p><img src="https://sfile.chatglm.cn/chatglm4/ee812a5f-d83b-4569-9eb9-8c35a9480678.png?image_process=format,webp"></p><h2 id="1-操作顺序可交换"><a href="#1-操作顺序可交换" class="headerlink" title="1. 操作顺序可交换"></a>1. 操作顺序可交换</h2><p><img src="https://sfile.chatglm.cn/chatglm4/d7923c78-d0fd-4c23-9496-7f5bc501ad49.png?image_process=format,webp"></p><h2 id="2-整体操作要对调"><a href="#2-整体操作要对调" class="headerlink" title="2. 整体操作要对调"></a>2. 整体操作要对调</h2><p><img src="https://sfile.chatglm.cn/chatglm4/c7956b85-5764-42b5-87f0-b28f16415a12.png?image_process=format,webp"></p><h2 id="3-重复操作会还原"><a href="#3-重复操作会还原" class="headerlink" title="3. 重复操作会还原"></a>3. 重复操作会还原</h2><p><img src="https://sfile.chatglm.cn/chatglm4/a5aa7739-c181-4aff-b3f6-7f5f03e62e72.png?image_process=format,webp"></p><h2 id="4-转置的优良性"><a href="#4-转置的优良性" class="headerlink" title="4. 转置的优良性"></a>4. 转置的优良性</h2><p><img src="https://sfile.chatglm.cn/chatglm4/5ac898cc-c317-46f6-80a8-3248bc293ed6.png?image_process=format,webp"></p><h2 id="5-逆矩阵的定义"><a href="#5-逆矩阵的定义" class="headerlink" title="5. 逆矩阵的定义"></a>5. 逆矩阵的定义</h2><p><img src="https://sfile.chatglm.cn/chatglm4/3530135b-b40d-4722-89ff-b40e10c033e1.png?image_process=format,webp"></p><h2 id="6-伴随矩阵的推导"><a href="#6-伴随矩阵的推导" class="headerlink" title="6. 伴随矩阵的推导"></a>6. 伴随矩阵的推导</h2><p> <img src="https://sfile.chatglm.cn/chatglm4/539ac5ab-dcc1-4e8f-9a92-b19f51619b6a.png?image_process=format,webp"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://sfile.chatglm.cn/chatglm4/5e2bf10b-cb2e-444f-95af-4b8c8ab624fa.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/12250f96-cab4-4b3a-8d41-113d07b90b9a.png?image_process=format,webp"></p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二重积分</title>
      <link href="/2024/04/27/%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86/"/>
      <url>/2024/04/27/%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="二重积分计算法"><a href="#二重积分计算法" class="headerlink" title="二重积分计算法"></a>二重积分计算法</h1><p><img src="https://sfile.chatglm.cn/chatglm4/d2394881-edfd-4142-ba86-9a713061b9f1.png?image_process=format,webp"></p><hr><h2 id="如何看懂二重积分"><a href="#如何看懂二重积分" class="headerlink" title="如何看懂二重积分"></a>如何看懂二重积分</h2><p><img src="https://sfile.chatglm.cn/chatglm4/ba044677-3586-4e36-8d21-7377e3b6138c.png?image_process=format,webp"></p><h2 id="二重积分的几何意义"><a href="#二重积分的几何意义" class="headerlink" title="二重积分的几何意义"></a>二重积分的几何意义</h2><p><img src="https://sfile.chatglm.cn/chatglm4/b8b6cbcc-3c82-4457-b3e3-0a5b1fa4dc7b.png?image_process=format,webp"></p><h2 id="用质量理解二重积分"><a href="#用质量理解二重积分" class="headerlink" title="用质量理解二重积分"></a>用质量理解二重积分</h2><p><img src="https://sfile.chatglm.cn/chatglm4/f55af30f-79ec-4a4e-9b66-2bc0b908cf96.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/ad327363-aa52-495e-959f-97c8f82c8d0e.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/f3c4d2e2-a0d7-4e69-8672-2d4ddda7ff46.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/6a8f6724-0e4a-432b-b3a5-fc162a6c7564.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/ceba96c4-f429-4834-9035-f9a26cf3fcfe.png?image_process=format,webp"></p><h2 id="二重积分的运算性质"><a href="#二重积分的运算性质" class="headerlink" title="二重积分的运算性质"></a>二重积分的运算性质</h2><p><img src="https://sfile.chatglm.cn/chatglm4/1512d0e0-1f24-4d3f-b94f-cbf88accf43e.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/c6e697f2-c130-4261-b13f-81f7c1f58ecb.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/373cb315-90fd-4a77-bbb8-e02301c7bcaf.png?image_process=format,webp"></p><h2 id="二重积分的普通对称性"><a href="#二重积分的普通对称性" class="headerlink" title="二重积分的普通对称性"></a>二重积分的普通对称性</h2><p><img src="https://sfile.chatglm.cn/chatglm4/0d3aa2e0-3a27-4634-b3a6-cbb16aecc042.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/937f2118-c910-421b-bfa4-b8135ac7c2a5.png?image_process=format,webp"></p><h2 id="二重积分的轮换对称性"><a href="#二重积分的轮换对称性" class="headerlink" title="二重积分的轮换对称性"></a>二重积分的轮换对称性</h2><p><img src="https://sfile.chatglm.cn/chatglm4/7b4ce07b-3c37-4eda-b659-c739297747bc.png?image_process=format,webp"></p><h2 id="更特殊的轮换对称性"><a href="#更特殊的轮换对称性" class="headerlink" title="更特殊的轮换对称性"></a>更特殊的轮换对称性</h2><p><img src="https://sfile.chatglm.cn/chatglm4/9abfcdff-5ddf-4eba-9164-1e426cfe8750.png?image_process=format,webp"></p><hr><h1 id="极坐标形式的二重积分"><a href="#极坐标形式的二重积分" class="headerlink" title="极坐标形式的二重积分"></a>极坐标形式的二重积分</h1><h2 id="极坐标"><a href="#极坐标" class="headerlink" title="极坐标"></a>极坐标</h2><p><img src="https://sfile.chatglm.cn/chatglm4/0617fb80-f336-400a-81bb-5b84fc8915e5.png?image_process=format,webp"></p><h2 id="常见的极坐标方程曲线"><a href="#常见的极坐标方程曲线" class="headerlink" title="常见的极坐标方程曲线"></a>常见的极坐标方程曲线</h2><p><img src="https://sfile.chatglm.cn/chatglm4/62bfb722-facf-4223-a63c-b618e1af704a.png?image_process=format,webp"></p><h2 id="极坐标形式计算"><a href="#极坐标形式计算" class="headerlink" title="极坐标形式计算"></a>极坐标形式计算</h2><p><img src="https://sfile.chatglm.cn/chatglm4/c95cb091-64f3-4946-a6e1-aa5d8ceb77ee.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/dcf09190-e996-44dd-bc55-7dd372e6745b.png?image_process=format,webp"></p><h2 id="适用极坐标形式的情形"><a href="#适用极坐标形式的情形" class="headerlink" title="适用极坐标形式的情形"></a>适用极坐标形式的情形</h2><p><img src="https://sfile.chatglm.cn/chatglm4/3cffa694-8c04-4d91-ad40-058641db7554.png?image_process=format,webp"></p><hr><h3 id="eg1："><a href="#eg1：" class="headerlink" title="eg1："></a>eg1：</h3><p><img src="https://sfile.chatglm.cn/chatglm4/e9b8dd7f-ee52-43bf-9794-9c9d012ca4d5.png?image_process=format,webp"></p><h3 id="eg2"><a href="#eg2" class="headerlink" title="eg2:"></a>eg2:</h3><p><img src="https://sfile.chatglm.cn/chatglm4/39e0de24-cd11-46e1-b915-bcc22b1376cb.png?image_process=format,webp"></p><h3 id="eg3"><a href="#eg3" class="headerlink" title="eg3:"></a>eg3:</h3><p><img src="https://sfile.chatglm.cn/chatglm4/edf9b67f-6ae3-4f1f-921e-5de0679aaef6.png?image_process=format,webp"></p><h3 id="eg4"><a href="#eg4" class="headerlink" title="eg4:"></a>eg4:</h3><p><img src="https://sfile.chatglm.cn/chatglm4/982707b9-fe9a-4927-9595-9f5906eb0be7.png?image_process=format,webp"></p><h3 id="eg5"><a href="#eg5" class="headerlink" title="eg5:"></a>eg5:</h3><p><img src="https://sfile.chatglm.cn/chatglm4/7b3ee435-e781-4da6-8a40-17c2d9212210.png?image_process=format,webp"></p><h3 id="eg6"><a href="#eg6" class="headerlink" title="eg6:"></a>eg6:</h3><p><img src="https://sfile.chatglm.cn/chatglm4/1935cd9a-2694-4188-989f-9251501b1fa4.png?image_process=format,webp"></p><h3 id="eg7"><a href="#eg7" class="headerlink" title="eg7:"></a>eg7:</h3><p><img src="https://sfile.chatglm.cn/chatglm4/f1f4d022-a241-4f25-a28b-5371997e2c47.png?image_process=format,webp"></p><h3 id="eg8"><a href="#eg8" class="headerlink" title="eg8:"></a>eg8:</h3><p><img src="https://sfile.chatglm.cn/chatglm4/5404c4d9-c270-4ade-94f7-4f2347523c67.png?image_process=format,webp"></p><h2 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h2><p><img src="https://sfile.chatglm.cn/chatglm4/6c12217c-2290-4011-8661-b3395ad78c37.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/19052431-4545-4224-b825-cea171f48e25.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/644b99f7-69ca-484c-86fa-0be93e292e90.png?image_process=format,webp"></p>]]></content>
      
      
      <categories>
          
          <category> 积分学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>重积分刷题</title>
      <link href="/2024/04/27/%E9%87%8D%E7%A7%AF%E5%88%86%E5%88%B7%E9%A2%98/"/>
      <url>/2024/04/27/%E9%87%8D%E7%A7%AF%E5%88%86%E5%88%B7%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="重积分刷题"><a href="#重积分刷题" class="headerlink" title="重积分刷题"></a>重积分刷题</h1>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆矩阵</title>
      <link href="/2024/04/27/%E9%80%86%E7%9F%A9%E9%98%B5/"/>
      <url>/2024/04/27/%E9%80%86%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h1><p><img src="https://sfile.chatglm.cn/chatglm4/159c7294-47f5-45e5-9ab3-f2931cc6dccf.png?image_process=format,webp"></p><hr><h2 id="啥是逆矩阵？"><a href="#啥是逆矩阵？" class="headerlink" title="啥是逆矩阵？"></a>啥是逆矩阵？</h2><p><img src="https://sfile.chatglm.cn/chatglm4/ec8d7a8d-47fa-4e6c-a67f-a5d7ce5bcc28.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/e4723ee7-073d-4487-bb6f-669699db7c0e.png?image_process=format,webp"></p><h2 id="逆矩阵咋求？"><a href="#逆矩阵咋求？" class="headerlink" title="逆矩阵咋求？"></a>逆矩阵咋求？</h2><h3 id="具体矩阵的逆矩阵的求法"><a href="#具体矩阵的逆矩阵的求法" class="headerlink" title="具体矩阵的逆矩阵的求法"></a>具体矩阵的逆矩阵的求法</h3><p><img src="https://sfile.chatglm.cn/chatglm4/ba9eb4ff-be59-41a9-804c-1b6d74df88bc.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/a9f85afe-e205-4667-bbd7-f57256461778.png?image_process=format,webp"></p><h3 id="抽象矩阵的逆矩阵的求法"><a href="#抽象矩阵的逆矩阵的求法" class="headerlink" title="抽象矩阵的逆矩阵的求法"></a>抽象矩阵的逆矩阵的求法</h3><p><img src="https://sfile.chatglm.cn/chatglm4/7f6a49e6-b0f7-4eef-9f9b-8977b2380ce3.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/bc00152a-e748-4292-9d84-d67a01e3eabc.png?image_process=format,webp"></p><h2 id="矩阵方程—先判断可逆"><a href="#矩阵方程—先判断可逆" class="headerlink" title="矩阵方程—先判断可逆"></a>矩阵方程—先判断可逆</h2><p><img src="https://sfile.chatglm.cn/chatglm4/6f6eba48-037a-4ce1-90de-c3d9701eadef.png?image_process=format,webp"></p><hr><p><img src="https://sfile.chatglm.cn/chatglm4/3045e34e-47a9-40db-8731-40c3e213ac59.png?image_process=format,webp"></p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵及其运算</title>
      <link href="/2024/04/27/%E7%9F%A9%E9%98%B5%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97/"/>
      <url>/2024/04/27/%E7%9F%A9%E9%98%B5%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="矩阵及其运算"><a href="#矩阵及其运算" class="headerlink" title="矩阵及其运算"></a>矩阵及其运算</h1><p><img src="https://sfile.chatglm.cn/chatglm4/80215fef-cd59-4974-99f7-a98b1a722cd8.png?image_process=format,webp"></p><hr><h2 id="矩阵是个啥？"><a href="#矩阵是个啥？" class="headerlink" title="矩阵是个啥？"></a>矩阵是个啥？</h2><p><img src="https://sfile.chatglm.cn/chatglm4/85eb4cd7-131a-465c-a7d4-e5d2780c43e9.png?image_process=format,webp"></p><h2 id="矩阵与行列式的关系"><a href="#矩阵与行列式的关系" class="headerlink" title="矩阵与行列式的关系"></a>矩阵与行列式的关系</h2><p><img src="https://sfile.chatglm.cn/chatglm4/7b922d5c-d842-42b7-b9b7-1c87bce05ff7.png?image_process=format,webp"></p><h2 id="矩阵的同型和相等"><a href="#矩阵的同型和相等" class="headerlink" title="矩阵的同型和相等"></a>矩阵的同型和相等</h2><p><img src="https://sfile.chatglm.cn/chatglm4/1b3ba54c-08d5-49d0-bcec-18ee01619e2c.png?image_process=format,webp"></p><hr><h2 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h2><h3 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h3><p><img src="https://sfile.chatglm.cn/chatglm4/4825d857-b0be-49c5-89e4-b53b6317dc61.png?image_process=format,webp"></p><h3 id="数与矩阵相乘"><a href="#数与矩阵相乘" class="headerlink" title="数与矩阵相乘"></a>数与矩阵相乘</h3><p><img src="https://sfile.chatglm.cn/chatglm4/e3df807b-283b-4a00-b713-fe56c0536381.png?image_process=format,webp"></p><h3 id="矩阵与矩阵相乘"><a href="#矩阵与矩阵相乘" class="headerlink" title="矩阵与矩阵相乘"></a>矩阵与矩阵相乘</h3><p><img src="https://sfile.chatglm.cn/chatglm4/12faf5c9-566d-49b5-a365-e2676da380ac.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/f1923748-dfdd-4c82-affd-c269eebbe017.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/c6a6e84e-32ca-401d-b109-a89308ef434d.png?image_process=format,webp"></p><h3 id="矩阵乘法的性质"><a href="#矩阵乘法的性质" class="headerlink" title="矩阵乘法的性质"></a>矩阵乘法的性质</h3><p><img src="https://sfile.chatglm.cn/chatglm4/83da144e-d7cd-4eac-9038-820bf9c61bcc.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/be5c2444-d68e-4825-962f-785aba97f212.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/9544af1f-6867-4a16-a4b4-f2311ab87497.png?image_process=format,webp"></p><hr><h2 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h2><h3 id="八个特殊矩阵"><a href="#八个特殊矩阵" class="headerlink" title="八个特殊矩阵"></a>八个特殊矩阵</h3><p><img src="https://sfile.chatglm.cn/chatglm4/cff3cc02-3755-4e3e-98c3-762fbbca50ae.png?image_process=format,webp"></p><h3 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h3><p><img src="https://sfile.chatglm.cn/chatglm4/b4693bfa-43c2-4c42-ad58-ab6a28a35cf4.png?image_process=format,webp"></p><h3 id="伴随矩阵"><a href="#伴随矩阵" class="headerlink" title="伴随矩阵"></a>伴随矩阵</h3><p><img src="https://sfile.chatglm.cn/chatglm4/92906753-ac9e-4db2-bc72-05ddfc4f7876.png?image_process=format,webp"></p><hr><h2 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h2><h3 id="什么是方阵？"><a href="#什么是方阵？" class="headerlink" title="什么是方阵？"></a>什么是方阵？</h3><p>方阵是线性代数中的一个概念，指的是行数和列数相等的矩阵。一个$( m \times n )的矩阵，如果( m &#x3D; n )，则该矩阵是方阵。方阵通常用( n \times n )表示，其中( n )$称为方阵的阶。<br>例如，一个2阶方阵如下所示：<br>$<br>\begin{bmatrix}<br>a &amp; b \<br>c &amp; d<br>\end{bmatrix}<br>$<br>在这个例子中，矩阵有两行两列，因此是一个方阵。</p><h3 id="方阵的性质"><a href="#方阵的性质" class="headerlink" title="方阵的性质"></a>方阵的性质</h3><p><img src="https://sfile.chatglm.cn/chatglm4/762c0098-7120-4c71-81ce-d76b7c60646b.png?image_process=format,webp"></p><hr><p><img src="https://sfile.chatglm.cn/chatglm4/3045e34e-47a9-40db-8731-40c3e213ac59.png?image_process=format,webp"></p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>行列式的计算</title>
      <link href="/2024/04/27/%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
      <url>/2024/04/27/%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="行列式的计算"><a href="#行列式的计算" class="headerlink" title="行列式的计算"></a>行列式的计算</h1><p><img src="https://sfile.chatglm.cn/chatglm4/9f911959-ec20-4936-95f6-c1dc045e34ba.png?image_process=format,webp"></p><hr><h2 id="计算行列式的方法"><a href="#计算行列式的方法" class="headerlink" title="计算行列式的方法"></a>计算行列式的方法</h2><p><img src="https://sfile.chatglm.cn/chatglm4/640c3464-5aa8-403c-9244-d10034fdacfc.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/af770304-79ef-40ef-9753-1a5074a58eaf.png?image_process=format,webp"></p><h3 id="行（列）相等型"><a href="#行（列）相等型" class="headerlink" title="行（列）相等型"></a>行（列）相等型</h3><p><img src="https://sfile.chatglm.cn/chatglm4/cbbf38cd-0ea3-43e3-b33d-482932f705d3.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/4bc14cdc-6ef3-4833-9cda-e4c5a4a10099.png?image_process=format,webp"></p><h3 id="爪型行列式"><a href="#爪型行列式" class="headerlink" title="爪型行列式"></a>爪型行列式</h3><p><img src="https://sfile.chatglm.cn/chatglm4/4e1da424-6d01-4352-8543-5aa179a9e21e.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/a420f8c7-8e54-447b-af49-4c3a0be987f6.png?image_process=format,webp"></p><h3 id="矩阵分块行列式"><a href="#矩阵分块行列式" class="headerlink" title="矩阵分块行列式"></a>矩阵分块行列式</h3><p><img src="https://sfile.chatglm.cn/chatglm4/d6b82b23-9cc3-415f-9b64-2a275859da92.png"></p><p><img src="https://sfile.chatglm.cn/chatglm4/e8348e3d-901e-4ad9-b79d-6678755f39e1.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/2da3a85e-cee9-4a44-805b-afe61098a4a8.png?image_process=format,webp"></p><h2 id="行列式展开定理计算行列式"><a href="#行列式展开定理计算行列式" class="headerlink" title="行列式展开定理计算行列式"></a>行列式展开定理计算行列式</h2><h3 id="加边法"><a href="#加边法" class="headerlink" title="加边法"></a>加边法</h3><p><img src="https://sfile.chatglm.cn/chatglm4/632671bc-7c52-4431-bd75-62f9f00300c0.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/d3bcaa7a-9557-4cb7-acd4-054f5751a13a.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/7735a91d-5530-4a69-960d-f2621b40a3b2.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/555a14ce-c2b7-4c65-9cbd-a300e5a5243f.png?image_process=format,webp"></p><h3 id="么型行列式"><a href="#么型行列式" class="headerlink" title="么型行列式"></a>么型行列式</h3><p><img src="https://sfile.chatglm.cn/chatglm4/706cb89b-d47e-45fb-b900-faf5223bf78b.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/93620dd7-0e55-45c8-9313-2c35cc2c3547.png?image_process=format,webp"></p><h3 id="川型行列式"><a href="#川型行列式" class="headerlink" title="川型行列式"></a>川型行列式</h3><p><img src="https://sfile.chatglm.cn/chatglm4/57f3c4d7-9486-4836-a66c-2d41409ccb11.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/9a7d7850-f4f2-4011-8312-386a04bc6471.png?image_process=format,webp"></p><h3 id="范德蒙行列式"><a href="#范德蒙行列式" class="headerlink" title="范德蒙行列式"></a>范德蒙行列式</h3><p><img src="https://sfile.chatglm.cn/chatglm4/bd67501c-254b-4cb2-9962-4f6beeaed3e4.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/08f8e944-1402-47de-bb91-6f05b3aee4d1.png?image_process=format,webp"></p><hr><h2 id="用矩阵表示行列式"><a href="#用矩阵表示行列式" class="headerlink" title="用矩阵表示行列式"></a>用矩阵表示行列式</h2><p><img src="https://sfile.chatglm.cn/chatglm4/95c6c9f7-8ef6-4ebd-8eb9-1517aa7688d8.png?image_process=format,webp"></p><hr><p><img src="https://sfile.chatglm.cn/chatglm4/3f85fbce-5487-4f81-82ad-e724e0d804d8.png?image_process=format,webp"></p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行列式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三重积分</title>
      <link href="/2024/04/26/%E4%B8%89%E9%87%8D%E7%A7%AF%E5%88%86/"/>
      <url>/2024/04/26/%E4%B8%89%E9%87%8D%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="三重积分的计算"><a href="#三重积分的计算" class="headerlink" title="三重积分的计算"></a>三重积分的计算</h1><hr><h2 id="先一后二"><a href="#先一后二" class="headerlink" title="先一后二"></a>先一后二</h2><p>$I &#x3D; {\int\int\int }_{\Omega}f(x, y, z)d_v$</p><ol><li>D（投影区域）：联立消z</li><li>下表面：$z &#x3D; z_1(x, y)$</li><li>上表面：$z &#x3D; z_2(x, y)$</li></ol><p>$I &#x3D; \int\int_D dxdy \int_{z_1(x,y)}^{z_2(x, y)}f{(x,y,z)}d_z$</p><p><img src="https://sfile.chatglm.cn/chatglm4/fc498e95-346b-49f9-a384-d7a0a3ac7067.png?image_process=format,webp"></p><hr><h2 id="柱面坐标"><a href="#柱面坐标" class="headerlink" title="柱面坐标"></a>柱面坐标</h2><ol><li><p>D（投影区域）：联立消z</p></li><li><p>下表面：$z &#x3D; z_1(x, y)$</p></li><li><p>上表面：$z &#x3D; z_2(x, y)$</p></li></ol><p>在柱面坐标里，</p><ol><li>D—&gt;$\alpha\leq\theta\leq\beta$  $P_{1}(\theta)\leq\rho\leq P_{2}(\theta)$​</li><li>$z &#x3D; z_1(x, y)$—&gt;$z_1(\rho_1, \theta)$</li><li>$z &#x3D; z_2(x, y)$—&gt;$z_2(\rho_2, \theta)$</li></ol><p>转化方法：</p><p>$\begin{cases}   x&#x3D;\rho\cos\theta \    y&#x3D;\rho\sin\theta \end{cases}$</p><p>结果表示：<br>$I&#x3D;\int_{\alpha}^{\beta}d\theta\int_{\rho_{1}(\theta)}^{\rho_{2}(\theta)}\rho\cdot d\rho\cdot\int_{z(\rho,\theta)}^{z(\rho,\theta)}f(\rho cos\theta,\rho sin\theta,z)dz$</p><hr><h2 id="先二后一"><a href="#先二后一" class="headerlink" title="先二后一"></a>先二后一</h2><p>$c\leq z \leq  d$</p><p>$\int\int\int_{\Omega} fdv$ &#x3D; $\int_c^d dz \iint_{D_z} f(x,y,z)\cdot dxdy$</p><p><img src="https://sfile.chatglm.cn/chatglm4/42d25a71-7e0d-4523-9a3c-287e93a8b5fc.png?image_process=format,webp"></p><hr><h3 id="eg1"><a href="#eg1" class="headerlink" title="eg1:"></a>eg1:</h3><p>求$\ I&#x3D;\int \int\int_\Omega xdv $ : Ω由三个坐标面及平面x+2y+z&#x3D;1围成</p><p><img src="https://sfile.chatglm.cn/chatglm4/5ff0e801-da60-4329-999e-4f4268ed486e.png?image_process=format,webp" alt="img"></p><h3 id="eg2"><a href="#eg2" class="headerlink" title="eg2:"></a>eg2:</h3><p>求$\int \int\int_{\Omega }z\cdot dv ，\Omega $由$z&#x3D;x^{2}+y^{2}及z&#x3D;4$围成</p><p><img src="https://sfile.chatglm.cn/img2text/9703be5a-9a1a-42e5-b2b3-bd42c8592df5.jpg"></p><p>要计算三重积分 $\int \int \int_{\Omega} z , dv$，其中 $\Omega$ 由曲面 $z &#x3D; x^2 + y^2$ 和平面 $z &#x3D; 4$ 围成，我们可以按照以下步骤进行：</p><ol><li><p><strong>确定积分区域</strong>：首先，我们需要确定积分区域 $\Omega$。由于区域由曲面 $z &#x3D; x^2 + y^2$ 和平面 $z &#x3D; 4$ 围成，我们可以推断积分区域是在这两个曲面之间的空间区域。</p></li><li><p><strong>设置积分限</strong>：接下来，我们需要为每个变量设置积分限。由于这是一个三维积分，我们需要为 $x$、$y$ 和 $z$ 分别设置积分限。</p><ul><li><p>对于 $x$ 和 $y$，积分限将是由曲面 $z &#x3D; x^2 + y^2$ 和 $z &#x3D; 4$ 在 $xy$ 平面上投影形成的区域。这个区域是一个圆，半径为 2（因为当 $z &#x3D; 4$ 时，$x^2 + y^2 &#x3D; 4$）。</p></li><li><p>对于 $z$，积分限是从 $z &#x3D; x^2 + y^2$ 到 $z &#x3D; 4$。</p></li></ul></li><li><p><strong>写出积分表达式</strong>：积分表达式将是 $\int \int \int_{\Omega} z , dv$，其中 $dv$ 是体积元素，可以表示为 $dz , dy , dx$。</p></li><li><p><strong>进行积分</strong>：最后，按照积分限进行积分计算。<br>  用数学符号表示，积分表达式将是：</p></li></ol><p>  $\int_{-2}^{2}\int_{-\sqrt{4-x^2}}^{\sqrt{4-x^2}}\int_{x^2+y^2}^4z\mathrm{d}z\mathrm{d}y\mathrm{d}x$   </p><ul><li>法一（先一后二）</li></ul><p>  <img src="https://sfile.chatglm.cn/chatglm4/62a2fe97-259f-4fa3-af98-6e4c51420974.png?image_process=format,webp" alt="img"></p><ul><li>法二   （柱面坐标法）</li></ul><p>  <img src="https://sfile.chatglm.cn/chatglm4/433089d7-c8a8-419f-9226-115a4dc8c576.png?image_process=format,webp" alt="img"></p><ul><li>法三    （先二后一）</li></ul><p>  <img src="https://sfile.chatglm.cn/chatglm4/500cbdc0-10b1-452e-bbc6-0b038ba3f8f1.png?image_process=format,webp"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在计算多重积分时，”先一后二”和”先二后一”是两种不同的积分顺序策略，它们适用于不同类型的积分区域和被积函数。</p><ol><li>先一后二（先算单积分，再算双积分）：<br>这种积分顺序通常适用于积分区域是圆柱形或者可以分解为一维和二维积分的情况。具体来说，就是先对一个变量积分，得到一个关于另外两个变量的函数，然后再对这两个变量进行积分。这种顺序通常在积分区域的边界与一个坐标轴平行时使用，例如：</li></ol><ul><li>当积分区域是由两个垂直于x轴的平面和两个垂直于y轴的曲线围成的区域时，可以先对x积分，再对y积分。</li><li>当积分区域是圆柱形时，比如在柱坐标下，可以先对半径r积分，再对角度θ和高度z积分。</li></ul><ol start="2"><li>先二后一（先算双积分，再算单积分）：<br>这种积分顺序通常适用于积分区域是矩形或者可以分解为二维和一维积分的情况。具体来说，就是先对两个变量进行积分，得到一个关于第三个变量的函数，然后再对这个变量进行积分。这种顺序通常在积分区域的边界与坐标轴垂直时使用，例如：</li></ol><ul><li>当积分区域是由两个垂直于x轴的曲线和两个垂直于y轴的平面围成的区域时，可以先对y和z积分，再对x积分。</li><li>当积分区域是由两个垂直于x轴的平面和两个垂直于z轴的曲线围成的区域时，可以先对x和z积分，再对y积分。<br>在实际计算中，选择哪种积分顺序取决于积分区域的形状和被积函数的特点。通常，我们会选择一种使得积分计算尽可能简单和直接的顺序。如果可能的话，可以尝试不同的积分顺序，看哪种方式更容易计算。此外，积分区域的对称性和被积函数的性质（如奇偶性）也可以帮助我们选择最合适的积分顺序。</li></ul><p>同时计算三重积分时应注意的几点：</p><ol><li>选择合适的积分顺序：三重积分的积分顺序可以是 dxdydz、dydxdz、dzdxdy、dxdzdy、dydzdx 或 dzdydx。选择正确的积分顺序可以简化计算过程。通常，我们应该选择使被积函数尽可能简单的顺序。</li><li>确定积分限：在计算三重积分时，需要确定积分的上下限。这些限通常由积分区域的边界决定。正确确定积分限对于计算正确的结果至关重要。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 积分学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Typora 语法大全</title>
      <link href="/2024/04/26/Typora%20%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8/"/>
      <url>/2024/04/26/Typora%20%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora-语法大全"><a href="#Typora-语法大全" class="headerlink" title="Typora 语法大全"></a>Typora 语法大全</h1><h2 id="Markdown-基本语法"><a href="#Markdown-基本语法" class="headerlink" title="Markdown 基本语法"></a>Markdown 基本语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>#一级标题 （快捷键Ctrl+1）</p><p>##二阶标题 （快捷键Ctrl+2）</p><p>###三阶标题 （快捷键Ctrl+3）</p><p>####四阶标题 （快捷键Ctrl+4）</p><p>#####五阶标题 （快捷键Ctrl+5）</p><p>######六阶标题 （快捷键Ctrl+6）</p><h3 id="如何生成目录"><a href="#如何生成目录" class="headerlink" title="如何生成目录"></a>如何生成目录</h3><p>@[TOC]</p><p>在文章开始地方输入[toc]，即可在对应位置插入目录<br>@[TOC]目录</p><p>以下不用写，直接写@<a href="%E7%9B%AE%E5%BD%95">TOC</a>即可自动获到目录中<br>#一阶标题 （快捷键Ctrl+1）<br>##二阶标题 （快捷键Ctrl+2）<br>###三阶标题 （快捷键Ctrl+3）<br>####四阶标题 （快捷键Ctrl+4）<br>#####五阶标题 （快捷键Ctrl+5）<br>######六阶标题 （快捷键Ctrl+6）</p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>下划线使用格式 下划线的内容&lt;\u&gt; 或者快捷键Ctrl+U</p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>删除线使用格式：~~ 删除线的内容</p><h3 id="字体加粗"><a href="#字体加粗" class="headerlink" title="字体加粗"></a>字体加粗</h3><p>前面某个字段使用两个*，加粗字体 或者快捷键Ctrl+B</p><h3 id="字体倾斜"><a href="#字体倾斜" class="headerlink" title="字体倾斜"></a>字体倾斜</h3><p>使用一个”星“，字体倾斜了 或者快捷键Ctrl+I</p><h3 id="图片的插入"><a href="#图片的插入" class="headerlink" title="图片的插入"></a>图片的插入</h3><p>直接拖你想要图片进来即可</p><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>使用快捷键Ctrl+K<br>使用2个反斜杠””，<br>[百度][<a href="https://www.baidu.com/]">https://www.baidu.com/]</a></p><h3 id="代码区域"><a href="#代码区域" class="headerlink" title="代码区域"></a>代码区域</h3><p>使用&#96;&#96;&#96;+回车即可在内容区编辑内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hellow world&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namespase std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;hello world&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有序无序列表"><a href="#有序无序列表" class="headerlink" title="有序无序列表"></a>有序无序列表</h3><h3 id="任务列表-："><a href="#任务列表-：" class="headerlink" title="任务列表 ："></a>任务列表 ：</h3><ul><li><input checked="" disabled="" type="checkbox"> java</li><li><input disabled="" type="checkbox"> python</li></ul><h4 id="创建无序列：-、-、-（后面加空格）"><a href="#创建无序列：-、-、-（后面加空格）" class="headerlink" title="创建无序列：+、-、 * （后面加空格）"></a>创建无序列：+、-、 * （后面加空格）</h4><p>如：</p><p>+ </p><ul><li><ul><li></li></ul></li></ul><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>1. </p><p>2. </p><h3 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a>水平分割线</h3><p>*** 或 - - -</p><hr><h3 id="引用的使用格式"><a href="#引用的使用格式" class="headerlink" title="引用的使用格式"></a>引用的使用格式</h3><p>“&gt;+空格”</p><blockquote><p>+ </p></blockquote><h3 id="表情"><a href="#表情" class="headerlink" title="表情"></a>表情</h3><p>:smile:</p><h3 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h3><ol><li>&emsp;</li><li>&ensp;</li></ol><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A --&gt; B</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">A-&gt;&gt;B: How are you?</span><br><span class="line">B--&gt;&gt;A:Great!</span><br></pre></td></tr></table></figure><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table><thead><tr><th align="center">学号</th><th align="center">姓名</th><th align="center">序号</th></tr></thead><tbody><tr><td align="center">小明</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p><img src="https://sfile.chatglm.cn/chatglm4/4ef1d96e-019e-423a-b126-fbe0822d374b.png?image_process=format,webp" alt="This is a picture" title="曹操"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>装饰器（decorator)</title>
      <link href="/2024/04/25/%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%88decorator)/"/>
      <url>/2024/04/25/%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%88decorator)/</url>
      
        <content type="html"><![CDATA[<h1 id="装饰器（decorator"><a href="#装饰器（decorator" class="headerlink" title="装饰器（decorator)"></a>装饰器（decorator)</h1><p>​<strong>在python中我们可以将函数作为参数传递给另一个参数, 而装饰器就是利用这一点制成的</strong></p><p><strong>eg:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_running</span>(<span class="params">f,x</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;f.__name__&#125;</span> is running.&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> f(x)</span><br><span class="line">result = print_running(square, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># square is running.</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure><h2 id="什么是装饰器？"><a href="#什么是装饰器？" class="headerlink" title="什么是装饰器？"></a>什么是装饰器？</h2><p>​<strong>装饰器本质上是一个函数，它会接受函数作为参数，在自己的内部根据这个函数定义一个新的函数，新函数在包含传入函数功能的同时，扩充了其他的功能，然后装饰器将新函数返回，我们就可以在代码里使用返回的新函数替代原来的传入函数</strong>。</p><p><strong>eg:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):  <span class="comment"># 定义一个装饰器</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):  <span class="comment"># 定义一个新函数</span></span><br><span class="line">        <span class="comment"># 添加的新功能</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;func.__name__&#125;</span> is running.&#x27;</span>)</span><br><span class="line">        result = func(*args, **kwargs)  <span class="comment"># 因为新函数可以使用原函数的功能，所以将原函数的返回值赋给result</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">return</span> wrapper  <span class="comment"># 返回装饰后的新函数</span></span><br></pre></td></tr></table></figure><p><strong>优化: 测量函数运行时间</strong></p><p><strong>eg:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;func.__name__&#125;</span> execution time is <span class="subst">&#123;end_time-start_time&#125;</span> seconds.&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><h2 id="怎么使用装饰器？"><a href="#怎么使用装饰器？" class="headerlink" title="怎么使用装饰器？"></a>怎么使用装饰器？</h2><p><strong>1. 直接使用</strong></p><p><strong>eg:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;func.__name__&#125;</span> execution time is <span class="subst">&#123;end_time-start_time&#125;</span> seconds.&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">decorated_square = decorator(square)  <span class="comment"># decorated_square 为装饰后的函数</span></span><br><span class="line"><span class="built_in">print</span>(decorated_square(<span class="number">10</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">square execution time is 0.0 seconds.</span></span><br><span class="line"><span class="string">100</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>2. 使用@</strong></p><p><strong>eg:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;func.__name__&#125;</span> execution time is <span class="subst">&#123;end_time-start_time&#125;</span> seconds.&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line"><span class="built_in">print</span>(square(<span class="number">10</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">square execution time is 0.0 seconds.</span></span><br><span class="line"><span class="string">100</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="装饰器生成器"><a href="#装饰器生成器" class="headerlink" title="装饰器生成器"></a>装饰器生成器</h2><p><strong>装饰器生成器会根据参数生成不同的装饰器</strong></p><p><strong>eg:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">threshold</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):  <span class="comment"># 定义一个装饰器</span></span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)  </span><span class="comment"># functools 是python内置的函数，能继承原函数的属性</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            start_time = time.time()</span><br><span class="line">            result = func(*args, **kwargs)</span><br><span class="line">            end_time = time.time()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> end_time - start_time &gt; threshold:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;func.__name__&#125;</span> took longer than <span class="subst">&#123;threshold&#125;</span> seconds&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorator  <span class="comment"># 返回生成的装饰器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(<span class="params"><span class="number">0.2</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleep_04</span>():</span><br><span class="line">    time.sleep(<span class="number">0.4</span>)</span><br><span class="line">    </span><br><span class="line">sleep_04()</span><br></pre></td></tr></table></figure><h2 id="使用装饰器的原因"><a href="#使用装饰器的原因" class="headerlink" title="使用装饰器的原因"></a>使用装饰器的原因</h2><ol><li><strong>代码复用</strong>：装饰器可以将一些通用的功能抽象出来，作为装饰器函数，然后可以在多个函数中使用同一个装饰器，从而实现代码的复用。</li><li><strong>代码清晰</strong>：通过使用装饰器，可以将与函数逻辑无关的功能分离出去，使得函数的代码更加清晰易读，提高了代码的可维护性。</li><li><strong>功能扩展</strong>：装饰器可以在不修改原函数代码的情况下，给函数添加新的功能，如日志记录、性能分析、权限验证等。</li><li><strong>解耦合</strong>：使用装饰器可以将不同层次的功能解耦合，使得各个功能模块之间的依赖性降低，提高了代码的灵活性和可扩展性。</li><li><strong>面向切面编程（AOP）</strong>：装饰器是面向切面编程的一种重要实现方式，可以在不改变原有代码的情况下，通过横向切割程序的功能，实现横切关注点的模块化管理。</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>归并排序（merge_sort)</title>
      <link href="/2024/04/25/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88merge_sort)/"/>
      <url>/2024/04/25/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88merge_sort)/</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序（merge-sort"><a href="#归并排序（merge-sort" class="headerlink" title="归并排序（merge_sort)"></a>归并排序（merge_sort)</h1><h2 id="什么是归并？"><a href="#什么是归并？" class="headerlink" title="什么是归并？"></a>什么是归并？</h2><ul><li><strong>假设现在列表分两段有序，如何将其合成为一个有序列表</strong></li></ul><p><img src="https://sfile.chatglm.cn/chatglm4/f9e120ec-c8e6-4503-a438-4f8f94e3db59.png?image_process=format,webp" alt="image-20240329155927795"></p><ul><li><strong>这种操作称为一次归并，对每一段的元素进行比较，直到其中一段被比完，直接将另一段的剩下的部分放在排好序的列表后即可</strong></li></ul><hr><h3 id="归并的代码实现"><a href="#归并的代码实现" class="headerlink" title="归并的代码实现"></a>归并的代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">li, low, mid, high</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    low,mid,high 将列表分为两段</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 定义两个指针，范围是列表的两段</span></span><br><span class="line">    i = low</span><br><span class="line">    j = mid + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 新建一个临时列表来存储排好序的元素</span></span><br><span class="line">    ltmp = []</span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= high:  <span class="comment"># 保证两个指针不会超出其所在范围</span></span><br><span class="line">        <span class="keyword">if</span> li[i] &lt; li[j]:</span><br><span class="line">            ltmp.append(li[i])</span><br><span class="line">            i += <span class="number">1</span>  <span class="comment"># 将左半指针右移一位</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ltmp.append(li[j])</span><br><span class="line">            j += <span class="number">1</span>  <span class="comment"># 将右半指针右移一位</span></span><br><span class="line">    <span class="comment"># while 执行完了，左右两边一定有一边被处理完了</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">        ltmp.append(li[i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        ltmp.append(li[j])</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    li[low:high + <span class="number">1</span>] = ltmp  <span class="comment"># 将新列表写回去</span></span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">merge(li, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(li)</span><br></pre></td></tr></table></figure><hr><h2 id="归并排序——使用归并"><a href="#归并排序——使用归并" class="headerlink" title="归并排序——使用归并"></a>归并排序——使用归并</h2><pre><code>    ### 实现归并排序分为三步</code></pre><ol><li><strong>分解：将列表越分越小，直至分成一个元素</strong></li><li><strong>终止条件：一个元素是有序的</strong></li><li><strong>合并：将两个有序列表归并，列表越来越大</strong></li></ol><p><img src="https://sfile.chatglm.cn/chatglm4/9d3f206e-3936-44b0-a756-978b43735567.png?image_process=format,webp" alt="image-20240329163131698"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 归并过程</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">li, low, mid, high</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    low,mid,high 将列表分为两段</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 定义两个指针，范围是列表的两段</span></span><br><span class="line">    i = low</span><br><span class="line">    j = mid + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 新建一个临时列表来存储排好序的元素</span></span><br><span class="line">    ltmp = []</span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= high:  <span class="comment"># 保证两个指针不会超出其所在范围</span></span><br><span class="line">        <span class="keyword">if</span> li[i] &lt; li[j]:</span><br><span class="line">            ltmp.append(li[i])</span><br><span class="line">            i += <span class="number">1</span>  <span class="comment"># 将左半指针右移一位</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ltmp.append(li[j])</span><br><span class="line">            j += <span class="number">1</span>  <span class="comment"># 将右半指针右移一位</span></span><br><span class="line">    <span class="comment"># while 执行完了，左右两边一定有一边被处理完了</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">        ltmp.append(li[i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        ltmp.append(li[j])</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    li[low:high + <span class="number">1</span>] = ltmp  <span class="comment"># 将新列表写回去</span></span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">li, low, high</span>):</span><br><span class="line">    <span class="keyword">if</span> low &lt; high:  <span class="comment"># 至少有两个元素，接下来开始递归，终止条件</span></span><br><span class="line">        <span class="comment"># 先分解</span></span><br><span class="line">        mid = (high + low) // <span class="number">2</span></span><br><span class="line">        merge_sort(li, low, mid)  <span class="comment"># 递归左边</span></span><br><span class="line">        merge_sort(li, mid + <span class="number">1</span>, high)  <span class="comment"># 递归右边</span></span><br><span class="line">        <span class="comment"># 开始归并</span></span><br><span class="line">        merge(li, low, mid, high)</span><br><span class="line">        </span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1000</span>))</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">random.shuffle(li)</span><br><span class="line"><span class="built_in">print</span>(li)</span><br><span class="line">merge_sort(li, <span class="number">0</span>, <span class="built_in">len</span>(li) - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(li)</span><br></pre></td></tr></table></figure><hr><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>​<strong>显然，一次归并操作的时间复杂度为<code>O(n)</code>，而归并了<code>logn</code>层，所以归并排序的时间复杂度为<code>O(nlogn)</code>。</strong></p><hr><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>​<strong>归并排序的空间复杂度为<code>O(n)</code></strong></p>]]></content>
      
      
      <categories>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计数排序</title>
      <link href="/2024/04/25/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>/2024/04/25/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><ul><li>对列表进行排序，已知列表中的数的范围都在0~100之间。设计时间复杂度为$O(n)$的算法。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_sort</span>(<span class="params">li, max_count=<span class="number">100</span></span>):</span><br><span class="line">    count = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_count + <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> li:</span><br><span class="line">        count[val] += <span class="number">1</span></span><br><span class="line">    li.clear()</span><br><span class="line">    <span class="keyword">for</span> idx, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(count):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(val):</span><br><span class="line">            li.append(idx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [random.randint(<span class="number">0</span>, <span class="number">100</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)]</span><br><span class="line"><span class="built_in">print</span>(li)</span><br><span class="line">count_sort(li)</span><br><span class="line"><span class="built_in">print</span>(li)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>希尔排序(Shell Sort)</title>
      <link href="/2024/04/25/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F(Shell%20Sort)/"/>
      <url>/2024/04/25/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F(Shell%20Sort)/</url>
      
        <content type="html"><![CDATA[<h1 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序(Shell Sort)"></a>希尔排序(Shell Sort)</h1><hr><h2 id="什么是希尔排序？"><a href="#什么是希尔排序？" class="headerlink" title="什么是希尔排序？"></a>什么是希尔排序？</h2><ul><li><strong>希尔排序(Shell Sort)是一种分组插入排序的排序算法</strong></li><li><strong>首先取整数$d_1 &#x3D; n&#x2F;2$，将元素分为$d_1$个组，每组相邻量元素之间距离为$d_1$，在各组内进行直接插入排序。</strong></li><li><strong>取第二个整数$d_2$，重复上述分组过程，知道$d_i$，即所有元素在同一组内进行直接插入排序。</strong></li><li><strong>希尔排序每趟并不使某些元素有序，而是使整体数据越来越接近有序；最后一趟排序使得所有数据有序。</strong></li></ul><p><img src="https://sfile.chatglm.cn/chatglm4/d5ac7579-58a0-4f6f-823d-ab5638eab47b.png?image_process=format,webp"></p><p><strong>eg:</strong><br><img src="https://sfile.chatglm.cn/chatglm4/1d810708-4a1f-4ca9-947f-51b011d22836.png?image_process=format,webp"><br><img src="https://sfile.chatglm.cn/chatglm4/336dbab5-8a18-4061-bb8e-11ab4b1003cd.png?image_process=format,webp"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在原插入排序算法的基础上，增加一个gap参数，代表分的组</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert_sort_gap</span>(<span class="params">lis, gap</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, <span class="built_in">len</span>(lis)):  <span class="comment"># i表示摸到的牌的下标</span></span><br><span class="line">        tmp = lis[i]</span><br><span class="line">        j = i - gap  <span class="comment"># j指的是手里的牌的下标</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> lis[j] &gt; tmp:</span><br><span class="line">            lis[j + gap] = lis[j]</span><br><span class="line">            j -= gap</span><br><span class="line">        <span class="comment"># 当手里的牌小于摸到的牌时，将摸到的牌放到手里牌的后一位。</span></span><br><span class="line">        <span class="comment"># 此时后一位时空的，因为大于手里的牌都往后移了一位。</span></span><br><span class="line">        lis[j + gap] = tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shell_sort</span>(<span class="params">li</span>):</span><br><span class="line">    d = <span class="built_in">len</span>(li) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> d &gt;= <span class="number">1</span>:</span><br><span class="line">        insert_sort_gap(li, d)</span><br><span class="line">        d = d // <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">random.shuffle(li)</span><br><span class="line">shell_sort(li)</span><br><span class="line"><span class="built_in">print</span>(li)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高数复习1</title>
      <link href="/2024/04/25/%E9%AB%98%E6%95%B0%E5%A4%8D%E4%B9%A01/"/>
      <url>/2024/04/25/%E9%AB%98%E6%95%B0%E5%A4%8D%E4%B9%A01/</url>
      
        <content type="html"><![CDATA[<h1 id="高数复习1"><a href="#高数复习1" class="headerlink" title="高数复习1"></a>高数复习1</h1><p>边听歌边复习，一个字爽！</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1478626970&auto=1&height=66"></iframe><hr><h2 id="数量积"><a href="#数量积" class="headerlink" title="数量积"></a>数量积</h2><p><img src="https://sfile.chatglm.cn/chatglm4/d06d599e-bfd1-47f4-919d-3debd7a3a059.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/0ea57075-308e-49d4-bca0-ef0dc31726ce.png?image_process=format,webp" alt="img"></p><h3 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h3><p><img src="https://sfile.chatglm.cn/chatglm4/e0476784-387c-4ba6-aae1-a2c6f7279aa4.png?image_process=format,webp" alt="img"></p><p><img src="https://sfile.chatglm.cn/chatglm4/04848e6a-4eda-4286-9630-be88af9b628c.png?image_process=format,webp"></p><hr><h2 id="向量积（又称为叉乘）"><a href="#向量积（又称为叉乘）" class="headerlink" title="向量积（又称为叉乘）"></a>向量积（又称为叉乘）</h2><h3 id="力矩"><a href="#力矩" class="headerlink" title="力矩"></a>力矩</h3><p><img src="https://sfile.chatglm.cn/chatglm4/6ed3e845-a786-4982-9984-75ad1b51b227.png?image_process=format,webp"></p><p><img src="https://sfile.chatglm.cn/chatglm4/42cc88cd-8814-4e73-836d-321127a92418.png?image_process=format,webp" alt="img"></p><p><img src="https://sfile.chatglm.cn/chatglm4/e126293d-51c3-4c90-8efe-c7bec32fdd8e.png?image_process=format,webp" alt="img"></p><p><img src="https://sfile.chatglm.cn/chatglm4/9a8e1300-5ca3-434c-beb9-13f95a5d8756.png?image_process=format,webp" alt="img"></p><p><img src="https://sfile.chatglm.cn/chatglm4/9da5b347-709d-43a8-b6c5-aa4e53e4e9d8.png?image_process=format,webp" alt="img"></p><p><img src="https://sfile.chatglm.cn/chatglm4/45fe9728-1933-40db-91ad-5b12b069055b.png?image_process=format,webp" alt="img"></p><p><img src="https://sfile.chatglm.cn/chatglm4/bc674d3d-08bd-4cae-9f85-ab1920a6ee9e.png?image_process=format,webp" alt="img"></p><p><img src="https://sfile.chatglm.cn/chatglm4/b9ff4aba-3c7f-40bd-81db-6ab8a73a222a.png?image_process=format,webp" alt="img"></p><p><img src="https://sfile.chatglm.cn/chatglm4/5f2873c8-7522-4b20-a0c5-eaeaaf265950.png?image_process=format,webp" alt="img"></p><h3 id="eg1"><a href="#eg1" class="headerlink" title="eg1:"></a>eg1:</h3><p><img src="https://sfile.chatglm.cn/chatglm4/bf4bd6c2-e229-4188-a357-18fcde3bcab7.png?image_process=format,webp" alt="img"></p><h3 id="eg2"><a href="#eg2" class="headerlink" title="eg2:"></a>eg2:</h3><p><img src="https://sfile.chatglm.cn/chatglm4/4ae7ebc1-446d-4624-846a-5190260ec3d8.png?image_process=format,webp" alt="img"></p><h2 id="混合积"><a href="#混合积" class="headerlink" title="混合积"></a>混合积</h2><p><img src="https://sfile.chatglm.cn/chatglm4/3c72c501-5f69-4623-b5bb-b03930eee198.png?image_process=format,webp" alt="img"></p><p><img src="https://sfile.chatglm.cn/chatglm4/b167333f-b09a-44ab-ad59-6d56011127fc.png?image_process=format,webp" alt="img"></p><p><img src="https://sfile.chatglm.cn/chatglm4/deb4c2d3-1db2-476d-a720-2936bd637f99.png?image_process=format,webp" alt="img"></p><h3 id="eg1-1"><a href="#eg1-1" class="headerlink" title="eg1:"></a>eg1:</h3><p><img src="https://sfile.chatglm.cn/chatglm4/34fc6b13-cd35-4bb2-8224-703d184a4113.png?image_process=format,webp" alt="img"></p><h3 id="eg2-1"><a href="#eg2-1" class="headerlink" title="eg2:"></a>eg2:</h3><p><img src="https://sfile.chatglm.cn/chatglm4/0383426c-1f3a-478b-8efa-6146c134aaa4.png?image_process=format,webp" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 向量计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性回归的简单实现</title>
      <link href="/2024/04/25/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%9A%84%E7%AE%80%E6%B4%81%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/04/25/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%9A%84%E7%AE%80%E6%B4%81%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="线性回归的简洁实现"><a href="#线性回归的简洁实现" class="headerlink" title="线性回归的简洁实现"></a>线性回归的简洁实现</h1><p>在过去的几年里，出于对深度学习强烈的兴趣， 许多公司、学者和业余爱好者开发了各种成熟的开源框架。 这些框架可以自动化基于梯度的学习算法中重复性的工作。 在 3.2节中，我们只运用了： （1）通过张量来进行数据存储和线性代数； （2）通过自动微分来计算梯度。 实际上，由于数据迭代器、损失函数、优化器和神经网络层很常用， 现代深度学习库也为我们实现了这些组件。</p><p>本节将介绍如何通过使用深度学习框架来简洁地实现 3.2节中的线性回归模型。</p><h1 id="生成数据集"><a href="#生成数据集" class="headerlink" title="生成数据集"></a>生成数据集</h1><p>与 3.2节中类似，我们首先生成数据集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义真实的权重向量true_w和偏置true_b</span></span><br><span class="line">true_w = torch.tensor([<span class="number">2</span>, -<span class="number">3.4</span>])</span><br><span class="line">true_b = <span class="number">4.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用d2l库中的synthetic_data函数生成合成数据集</span></span><br><span class="line"><span class="comment"># synthetic_data函数接受真实的权重、偏置和一个样本数量，生成特征矩阵features和标签向量labels</span></span><br><span class="line"><span class="comment"># 特征矩阵的每一行是一个样本，每一列是一个特征；标签向量中的每个元素是对应样本的标签</span></span><br><span class="line">features, labels = d2l.synthetic_data(true_w, true_b, <span class="number">1000</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="读取数据集"><a href="#读取数据集" class="headerlink" title="读取数据集"></a>读取数据集</h1><p>我们可以调用框架中现有的API来读取数据。 我们将和作为API的参数传递，并通过数据迭代器指定。 此外，布尔值表示是否希望数据迭代器对象在每个迭代周期内打乱数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_array</span>(<span class="params">data_arrays, batch_size, is_train=<span class="literal">True</span></span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    构造一个PyTorch数据迭代器。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    - data_arrays: 包含数据数组的元组，通常是一个特征数组和一个标签数组。</span></span><br><span class="line"><span class="string">    - batch_size: 每个批次的样本数量。</span></span><br><span class="line"><span class="string">    - is_train: 布尔值，表示是否为训练数据。如果是，则在迭代时随机打乱数据。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">    - DataLoader: 一个PyTorch数据迭代器，可以用于在训练和测试阶段提供数据批次。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    这个函数首先将输入的数据数组转换为一个TensorDataset，这是一个包装了数据数组的类，能够提供索引接口。</span></span><br><span class="line"><span class="string">    然后，使用DataLoader类来创建一个可迭代的数据加载器，它可以在每个迭代周期中提供大小为batch_size的数据批次。</span></span><br><span class="line"><span class="string">    如果is_train为True，则会在每个epoch开始时打乱数据，以便在训练过程中引入随机性。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dataset = data.TensorDataset(*data_arrays)  <span class="comment"># 将数据数组转换为TensorDataset</span></span><br><span class="line">    <span class="keyword">return</span> data.DataLoader(dataset, batch_size, shuffle=is_train)  <span class="comment"># 创建DataLoader</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置批处理大小</span></span><br><span class="line">batch_size = <span class="number">10</span></span><br><span class="line"><span class="comment"># 创建数据迭代器，传入特征和标签数组，以及批处理大小</span></span><br><span class="line">data_iter = load_array((features, labels), batch_size)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用的方式与我们在 3.2节中使用函数的方式相同。为了验证是否正常工作，让我们读取并打印第一个小批量样本。 与 3.2节不同，这里我们使用构造Python迭代器，并使用从迭代器中获取第一项。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">next</span>(<span class="built_in">iter</span>(data_iter))</span><br></pre></td></tr></table></figure><pre><code>[tensor([[-0.8421,  0.7613],         [ 0.9561, -0.2997],         [-1.0493,  0.9408],         [ 0.8585, -1.3308],         [ 0.4646,  0.2252],         [-0.6054,  0.1887],         [-0.1280,  0.1882],         [-0.9369, -0.8599],         [ 1.9123, -0.7680],         [-0.7061, -0.0104]]), tensor([[-0.0759],         [ 7.1076],         [-1.1003],         [10.4446],         [ 4.3523],         [ 2.3550],         [ 3.3027],         [ 5.2368],         [10.6245],         [ 2.8324]])]</code></pre><h1 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h1><p>当我们在 3.2节中实现线性回归时， 我们明确定义了模型参数变量，并编写了计算的代码，这样通过基本的线性代数运算得到输出。 但是，如果模型变得更加复杂，且当我们几乎每天都需要实现模型时，自然会想简化这个过程。 这种情况类似于为自己的博客从零开始编写网页。 做一两次是有益的，但如果每个新博客就需要工程师花一个月的时间重新开始编写网页，那并不高效。</p><p>对于标准深度学习模型，我们可以使用框架的预定义好的层。这使我们只需关注使用哪些层来构造模型，而不必关注层的实现细节。 我们首先定义一个模型变量，它是一个类的实例。 类将多个层串联在一起。 当给定输入数据时，实例将数据传入到第一层， 然后将第一层的输出作为第二层的输入，以此类推。 在下面的例子中，我们的模型只包含一个层，因此实际上不需要。 但是由于以后几乎所有的模型都是多层的，在这里使用会让你熟悉“标准的流水线”。netSequentialSequentialSequentialSequentialSequential</p><p>回顾 图3.1.2中的单层网络架构， 这一单层被称为全连接层（fully-connected layer）， 因为它的每一个输入都通过矩阵-向量乘法得到它的每个输出。</p><p>在PyTorch中，全连接层在类中定义。 值得注意的是，我们将两个参数传递到中。 第一个指定输入特征形状，即2，第二个指定输出特征形状，输出特征形状为单个标量，因此为1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入torch的nn模块，这是PyTorch中专门用于构建神经网络的核心模块</span></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个顺序模型net，它是一个按照顺序执行的一系列层的容器</span></span><br><span class="line"><span class="comment"># nn.Sequential是一个顺序容器，模块将按照它们在构造器中传递的顺序添加到它里面</span></span><br><span class="line">net = nn.Sequential(nn.Linear(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="初始化模型参数"><a href="#初始化模型参数" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h1><p>在使用之前，我们需要初始化模型参数。 如在线性回归模型中的权重和偏置。 深度学习框架通常有预定义的方法来初始化参数。 在这里，我们指定每个权重参数应该从均值为0、标准差为0.01的正态分布中随机采样， 偏置参数将初始化为零。</p><p>正如我们在构造时指定输入和输出尺寸一样， 现在我们能直接访问参数以设定它们的初始值。 我们通过选择网络中的第一个图层， 然后使用和方法访问参数。 我们还可以使用替换方法和来重写参数值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对网络的第一层（通常是线性层或全连接层）的权重进行初始化</span></span><br><span class="line"><span class="comment"># 使用正态分布随机初始化权重，均值设为0，标准差设为0.01</span></span><br><span class="line">net[<span class="number">0</span>].weight.data.normal_(<span class="number">0</span>, <span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将网络的第一层的偏置初始化为0</span></span><br><span class="line"><span class="comment"># 这通常是因为偏置可以看作是网络的“初始值”，而初始化为0意味着网络在开始时是中立的</span></span><br><span class="line">net[<span class="number">0</span>].bias.data.fill_(<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>tensor([0.])</code></pre><h1 id="定义损失函数¶"><a href="#定义损失函数¶" class="headerlink" title="定义损失函数¶"></a>定义损失函数¶</h1><p>计算均方误差使用的是类，也称为平方(L_2)范数。 默认情况下，它返回所有样本损失的平均值。MSELoss</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss = nn.MSELoss()</span><br></pre></td></tr></table></figure><h1 id="定义优化算法"><a href="#定义优化算法" class="headerlink" title="定义优化算法"></a>定义优化算法</h1><p>小批量随机梯度下降算法是一种优化神经网络的标准工具， PyTorch在模块中实现了该算法的许多变种。 当我们实例化一个实例时，我们要指定优化的参数 （可通过从我们的模型中获得）以及优化算法所需的超参数字典。 小批量随机梯度下降只需要设置值，这里设置为0.03。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.03</span>)</span><br></pre></td></tr></table></figure><h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><p>通过深度学习框架的高级API来实现我们的模型只需要相对较少的代码。 我们不必单独分配参数、不必定义我们的损失函数，也不必手动实现小批量随机梯度下降。 当我们需要更复杂的模型时，高级API的优势将大大增加。 当我们有了所有的基本组件，训练过程代码与我们从零开始实现时所做的非常相似。</p><p>回顾一下：在每个迭代周期里，我们将完整遍历一次数据集（）， 不停地从中获取一个小批量的输入和相应的标签。 对于每一个小批量，我们会进行以下步骤:train_data</p><p>通过调用生成预测并计算损失（前向传播）。net(X)l</p><p>通过进行反向传播来计算梯度。</p><p>通过调用优化器来更新模型参数。</p><p>为了更好的衡量训练效果，我们计算每个迭代周期后的损失，并打印它来监控训练过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num_epochs = <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">        l = loss(net(X) ,y)</span><br><span class="line">        trainer.zero_grad()</span><br><span class="line">        l.backward()</span><br><span class="line">        trainer.step()</span><br><span class="line">    l = loss(net(features), labels)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;l:f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>epoch 1, loss 0.000177epoch 2, loss 0.000097epoch 3, loss 0.000097</code></pre><p>下面我们比较生成数据集的真实参数和通过有限数据训练获得的模型参数。 要访问参数，我们首先从访问所需的层，然后读取该层的权重和偏置。 正如在从零开始实现中一样，我们估计得到的参数与生成数据的真实参数非常接近。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">w = net[<span class="number">0</span>].weight.data</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;w的估计误差：&#x27;</span>, true_w - w.reshape(true_w.shape))</span><br><span class="line">b = net[<span class="number">0</span>].bias.data</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b的估计误差：&#x27;</span>, true_b - b)</span><br></pre></td></tr></table></figure><pre><code>w的估计误差： tensor([-0.0003, -0.0004])b的估计误差： tensor([-0.0012])</code></pre><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li><p>我们可以使用PyTorch的高级API更简洁地实现模型。</p></li><li><p>在PyTorch中，模块提供了数据处理工具，模块定义了大量的神经网络层和常见损失函数。datann</p></li><li><p>我们可以通过结尾的方法将参数替换，从而初始化参数。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性回归从零开始</title>
      <link href="/2024/04/25/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"/>
      <url>/2024/04/25/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="线性回归的从零开始实现"><a href="#线性回归的从零开始实现" class="headerlink" title="线性回归的从零开始实现"></a>线性回归的从零开始实现</h1><p>在了解线性回归的关键思想之后，我们可以开始通过代码来动手实现线性回归了。 在这一节中，我们将从零开始实现整个方法， 包括数据流水线、模型、损失函数和小批量随机梯度下降优化器。 虽然现代的深度学习框架几乎可以自动化地进行所有这些工作，但从零开始实现可以确保我们真正知道自己在做什么。 同时，了解更细致的工作原理将方便我们自定义模型、自定义层或自定义损失函数。 在这一节中，我们将只使用张量和自动求导。 在之后的章节中，我们会充分利用深度学习框架的优势，介绍更简洁的实现方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br></pre></td></tr></table></figure><h1 id="生成数据集¶"><a href="#生成数据集¶" class="headerlink" title="生成数据集¶"></a>生成数据集¶</h1><p>为了简单起见，我们将根据带有噪声的线性模型构造一个人造数据集。 我们的任务是使用这个有限样本的数据集来恢复这个模型的参数。 我们将使用低维数据，这样可以很容易地将其可视化。 在下面的代码中，我们生成一个包含1000个样本的数据集， 每个样本包含从标准正态分布中采样的2个特征。 我们的合成数据集是一个矩阵$X \in R^{1000*2}$。</p><p>我们使用线性模型参数$w &#x3D; [2, -3.4]^T、b &#x3D; 4.2$和噪声项$\epsilon$生成数据集及其标签：</p><p>$y &#x3D; Xw + b + \epsilon$ (3.2.1)</p><p>$\epsilon$可以视为模型预测和标签时的潜在观测误差。 在这里我们认为标准假设成立，即<br>服从均值为0的正态分布。 为了简化问题，我们将标准差设为0.01。 下面的代码生成合成数据集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">synthetic_data</span>(<span class="params">w, b, num_examples</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;生成y = Xw + b + 噪声&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 生成特征矩阵X，其中每个特征值服从均值为0，标准差为1的正态分布</span></span><br><span class="line">    <span class="comment"># X的形状是(num_examples, len(w))，即(num_examples, 特征数量)</span></span><br><span class="line">    X = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (num_examples, <span class="built_in">len</span>(w)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算标签y，y = Xw + b，这里使用矩阵乘法torch.matmul(X, w)计算Xw</span></span><br><span class="line">    y = torch.matmul(X, w) + b</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 向y添加噪声，噪声服从均值为0，标准差为0.01的正态分布</span></span><br><span class="line">    <span class="comment"># 这样模拟真实数据集中的不确定性</span></span><br><span class="line">    y += torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, y.shape)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回特征矩阵X和标签向量y，y被重塑为(num_examples, 1)的形状</span></span><br><span class="line">    <span class="keyword">return</span> X, y.reshape((-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义真实的权重向量w和偏置b</span></span><br><span class="line">true_w = torch.tensor([<span class="number">2</span>, -<span class="number">3.4</span>])</span><br><span class="line">true_b = <span class="number">4.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用synthetic_data函数生成1000个样本的数据集</span></span><br><span class="line">features, labels = synthetic_data(true_w, true_b, <span class="number">1000</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意，features中的每一行都包含一个二维数据样本， labels中的每一行都包含一维标签值（一个标量）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;feature:&#x27;</span>, features[<span class="number">0</span>], <span class="string">&quot;\nlabel:&quot;</span>, labels[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><pre><code>feature: tensor([ 0.1752, -1.0727]) label: tensor([8.1913])</code></pre><p>通过生成第二个特征features[:, 1]和labels的散点图， 可以直观观察到两者之间的线性关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置图表大小。这个函数是d2l库提供的，它会调整图表的大小以适应显示。</span></span><br><span class="line">d2l.set_figsize()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用matplotlib的scatter函数绘制散点图。</span></span><br><span class="line"><span class="comment"># features[:, (1)]选取了特征矩阵的第二列（索引为1），即第二个特征的所有样本值。</span></span><br><span class="line"><span class="comment"># detach().numpy()将PyTorch张量转换为NumPy数组，以便在matplotlib中使用。</span></span><br><span class="line"><span class="comment"># labels.detach().numpy()将标签张量转换为NumPy数组。</span></span><br><span class="line"><span class="comment"># 最后的参数1指定了散点图点的大小。</span></span><br><span class="line">d2l.plt.scatter(features[:, (<span class="number">1</span>)].detach().numpy(), labels.detach().numpy(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：这段代码的最后一行末尾有一个分号&#x27;;&#x27;，这是可选的，用于阻止Python打印出scatter函数的返回值。</span></span><br></pre></td></tr></table></figure><h1 id="读取数据集"><a href="#读取数据集" class="headerlink" title="读取数据集"></a>读取数据集</h1><p>回想一下，训练模型时要对数据集进行遍历，每次抽取一小批量样本，并使用它们来更新我们的模型。 由于这个过程是训练机器学习算法的基础，所以有必要定义一个函数， 该函数能打乱数据集中的样本并以小批量方式获取数据。</p><p>在下面的代码中，我们定义一个data_iter函数， 该函数接收批量大小、特征矩阵和标签向量作为输入，生成大小为batch_size的小批量。 每个小批量包含一组特征和标签。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch  <span class="comment"># 导入PyTorch库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_iter</span>(<span class="params">batch_size, features, labels</span>):</span><br><span class="line">    <span class="comment"># 获取样本总数</span></span><br><span class="line">    num_examples = <span class="built_in">len</span>(features)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建一个列表，包含从0到num_examples - 1的所有索引</span></span><br><span class="line">    indices = <span class="built_in">list</span>(<span class="built_in">range</span>(num_examples))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 打乱索引列表，这样每次迭代时都会以不同的顺序读取数据</span></span><br><span class="line">    random.shuffle(indices)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 迭代整个数据集，每次提取一个批量的样本</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_examples, batch_size):</span><br><span class="line">        <span class="comment"># 计算当前批量的结束索引</span></span><br><span class="line">        batch_indices = torch.tensor(</span><br><span class="line">            indices[i: <span class="built_in">min</span>(i + batch_size, num_examples)])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用计算出的索引提取当前批量的特征和标签</span></span><br><span class="line">        <span class="keyword">yield</span> features[batch_indices], labels[batch_indices]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通常，我们利用GPU并行运算的优势，处理合理大小的“小批量”。 每个样本都可以并行地进行模型计算，且每个样本损失函数的梯度也可以被并行计算。 GPU可以在处理几百个样本时，所花费的时间不比处理一个样本时多太多。</p><p>我们直观感受一下小批量运算：读取第一个小批量数据样本并打印。 每个批量的特征维度显示批量大小和输入特征数。 同样的，批量的标签形状与batch_size相等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter(batch_size, features, labels):</span><br><span class="line">    <span class="built_in">print</span>(X, <span class="string">&#x27;\n&#x27;</span>, y)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><pre><code>tensor([[-3.0643,  1.0533],        [-0.9229,  1.5654],        [-0.0340,  0.0504],        [ 0.5661,  1.9557],        [-0.4642,  0.1759],        [ 0.5983,  1.1317],        [ 0.8255,  0.4834],        [ 1.4149,  0.3229],        [-0.7331,  1.1990],        [-0.6738,  1.0309]])  tensor([[-5.5173],        [-2.9610],        [ 3.9682],        [-1.3140],        [ 2.6727],        [ 1.5492],        [ 4.1854],        [ 5.9360],        [-1.3348],        [-0.6517]])</code></pre><p>当我们运行迭代时，我们会连续地获得不同的小批量，直至遍历完整个数据集。 上面实现的迭代对教学来说很好，但它的执行效率很低，可能会在实际问题上陷入麻烦。 例如，它要求我们将所有数据加载到内存中，并执行大量的随机内存访问。 在深度学习框架中实现的内置迭代器效率要高得多， 它可以处理存储在文件中的数据和数据流提供的数据。</p><h1 id="初始化模型参数"><a href="#初始化模型参数" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h1><p>在我们开始用小批量随机梯度下降优化我们的模型参数之前， 我们需要先有一些参数。 在下面的代码中，我们通过从均值为0、标准差为0.01的正态分布中采样随机数来初始化权重， 并将偏置初始化为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=(<span class="number">2</span>,<span class="number">1</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.zeros(<span class="number">1</span>, requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>在初始化参数之后，我们的任务是更新这些参数，直到这些参数足够拟合我们的数据。 每次更新都需要计算损失函数关于模型参数的梯度。 有了这个梯度，我们就可以向减小损失的方向更新每个参数。 因为手动计算梯度很枯燥而且容易出错，所以没有人会手动计算梯度。 我们使用 2.5节中引入的自动微分来计算梯度。</p><h1 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h1><p>接下来，我们必须定义模型，将模型的输入和参数同模型的输出关联起来。 回想一下，要计算线性模型的输出， 我们只需计算输入特征$X$和模型权重$w$的矩阵-向量乘法后加上偏置$b$。 注意，上面的<br>$Xw$是一个向量，而$b$是一个标量。 回想一下 2.1.3节中描述的广播机制： 当我们用一个向量加一个标量时，标量会被加到向量的每个分量上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">linreg</span>(<span class="params">X, w, b</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;线性回归模型&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> torch.matmul(X, w) + b</span><br></pre></td></tr></table></figure><h1 id="定义损失函数"><a href="#定义损失函数" class="headerlink" title="定义损失函数"></a>定义损失函数</h1><p>因为需要计算损失函数的梯度，所以我们应该先定义损失函数。 这里我们使用 3.1节中描述的平方损失函数。 在实现中，我们需要将真实值y的形状转换为和预测值y_hat的形状相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">squared_loss</span>(<span class="params">y_hat, y</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;均方损失&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (y_hat - y.reshape(y_hat.shape)) ** <span class="number">2</span> / <span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="定义优化算法"><a href="#定义优化算法" class="headerlink" title="定义优化算法"></a>定义优化算法</h1><p>正如我们在 3.1节中讨论的，线性回归有解析解。 尽管线性回归有解析解，但本书中的其他模型却没有。 这里我们介绍小批量随机梯度下降。</p><p>在每一步中，使用从数据集中随机抽取的一个小批量，然后根据参数计算损失的梯度。 接下来，朝着减少损失的方向更新我们的参数。 下面的函数实现小批量随机梯度下降更新。 该函数接受模型参数集合、学习速率和批量大小作为输入。每 一步更新的大小由学习速率lr决定。 因为我们计算的损失是一个批量样本的总和，所以我们用批量大小（batch_size） 来规范化步长，这样步长大小就不会取决于我们对批量大小的选择。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sgd</span>(<span class="params">params, lr, batch_size</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;小批量随机梯度下降&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 使用with torch.no_grad()确保在更新参数时不会计算梯度</span></span><br><span class="line">    <span class="comment"># 这是因为我们只是在应用已经计算出的梯度，而不需要在更新参数时再次计算梯度</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="comment"># 遍历模型中的每个参数</span></span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">            <span class="comment"># 根据梯度下降公式更新参数：</span></span><br><span class="line">            <span class="comment"># param = param - learning_rate * gradient</span></span><br><span class="line">            <span class="comment"># 这里除以batch_size是因为梯度是在一个批量上计算的</span></span><br><span class="line">            <span class="comment"># 所以需要将梯度平均化，以得到每个样本的梯度贡献</span></span><br><span class="line">            param -= lr * param.grad / batch_size</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 清零参数的梯度，为下一次梯度计算做准备</span></span><br><span class="line">            <span class="comment"># 这是因为在PyTorch中，梯度是累加的</span></span><br><span class="line">            <span class="comment"># 如果不清零，下一次计算梯度时，梯度会与上一次的梯度累加</span></span><br><span class="line">            param.grad.zero_()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><p>现在我们已经准备好了模型训练所有需要的要素，可以实现主要的训练过程部分了。 理解这段代码至关重要，因为从事深度学习后， 相同的训练过程几乎一遍又一遍地出现。 在每次迭代中，我们读取一小批量训练样本，并通过我们的模型来获得一组预测。 计算完损失后，我们开始反向传播，存储每个参数的梯度。 最后，我们调用优化算法sgd来更新模型参数。</p><p>概括一下，我们将执行以下循环：</p><ul><li><p>初始化参数</p></li><li><p>重复以下训练，直到完成</p></li><li><ul><li>计算梯度$g \leftarrow \partial_{w,b}\frac{1}{|\beta|}\sum_{i\in\beta}l(x^{(i)}, y^{(i)},w,b)$</li><li>更新参数$(w, b) \leftarrow (w, b) - ng$</li></ul></li></ul><p>在每个迭代周期（epoch）中，我们使用data_iter函数遍历整个数据集， 并将训练数据集中所有样本都使用一次（假设样本数能够被批量大小整除）。 这里的迭代周期个数num_epochs和学习率lr都是超参数，分别设为3和0.03。 设置超参数很棘手，需要通过反复试验进行调整。 我们现在忽略这些细节，以后会在 11节中详细介绍</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置学习率为0.03</span></span><br><span class="line">lr = <span class="number">0.03</span></span><br><span class="line"><span class="comment"># 设置训练周期数为3</span></span><br><span class="line">num_epochs = <span class="number">3</span></span><br><span class="line"><span class="comment"># 假设net是之前定义的线性回归模型函数</span></span><br><span class="line">net = linreg</span><br><span class="line"><span class="comment"># 假设loss是之前定义的平方损失函数</span></span><br><span class="line">loss = squared_loss</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="comment"># 遍历数据集，data_iter是之前定义的生成小批量数据的函数</span></span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter(batch_size, features, labels):</span><br><span class="line">        <span class="comment"># 计算小批量数据X和y的损失</span></span><br><span class="line">        l = loss(net(X, w, b), y)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 因为l是一个(batch_size, 1)形状的向量，我们需要对其所有元素进行求和</span></span><br><span class="line">        <span class="comment"># 以得到一个标量损失值，然后调用backward进行反向传播计算梯度</span></span><br><span class="line">        l.<span class="built_in">sum</span>().backward()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用小批量随机梯度下降法(sgd)更新模型的参数w和b</span></span><br><span class="line">        sgd([w, b], lr, batch_size)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在每个训练周期结束后，评估模型的损失</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="comment"># 计算整个训练集上的损失</span></span><br><span class="line">        train_l = loss(net(features, w, b), labels)</span><br><span class="line">        <span class="comment"># 打印当前周期数和平均损失</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;<span class="built_in">float</span>(train_l.mean()):f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>epoch 1, loss 0.038955epoch 2, loss 0.000141epoch 3, loss 0.000049</code></pre><p>因为我们使用的是自己合成的数据集，所以我们知道真正的参数是什么。 因此，我们可以通过比较真实参数和通过训练学到的参数来评估训练的成功程度。 事实上，真实参数和通过训练学到的参数确实非常接近。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;w的估计误差: <span class="subst">&#123;true_w - w.reshape(true_w.shape)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;b的估计误差: <span class="subst">&#123;true_b - b&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>w的估计误差: tensor([0.0003, 0.0002], grad_fn=&lt;SubBackward0&gt;)b的估计误差: tensor([0.0006], grad_fn=&lt;RsubBackward1&gt;)</code></pre><p>注意，我们不应该想当然地认为我们能够完美地求解参数。 在机器学习中，我们通常不太关心恢复真正的参数，而更关心如何高度准确预测参数。 幸运的是，即使是在复杂的优化问题上，随机梯度下降通常也能找到非常好的解。 其中一个原因是，在深度网络中存在许多参数组合能够实现高度精确的预测。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性回归 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
